/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub type __s8 = ffi::c_schar;
pub type __u8 = ffi::c_uchar;
pub type __s16 = ffi::c_short;
pub type __u16 = ffi::c_ushort;
pub type __s32 = ffi::c_int;
pub type __u32 = ffi::c_uint;
pub type __s64 = ffi::c_longlong;
pub type __u64 = ffi::c_ulonglong;
pub type s8 = __s8;
pub type u8_ = __u8;
pub type s16 = __s16;
pub type u16_ = __u16;
pub type s32 = __s32;
pub type u32_ = __u32;
pub type s64 = __s64;
pub type u64_ = __u64;
pub type __kernel_long_t = ffi::c_long;
pub type __kernel_ulong_t = ffi::c_ulong;
pub type __kernel_pid_t = ffi::c_int;
pub type __kernel_uid32_t = ffi::c_uint;
pub type __kernel_gid32_t = ffi::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_loff_t = ffi::c_longlong;
pub type __kernel_time64_t = ffi::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ffi::c_int;
pub type __kernel_clockid_t = ffi::c_int;
pub type __poll_t = ffi::c_uint;
pub type __kernel_dev_t = u32_;
pub type dev_t = __kernel_dev_t;
pub type umode_t = ffi::c_ushort;
pub type pid_t = __kernel_pid_t;
pub type clockid_t = __kernel_clockid_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type loff_t = __kernel_loff_t;
pub type ktime_t = s64;
pub type sector_t = u64_;
pub type blkcnt_t = u64_;
pub type gfp_t = ffi::c_uint;
pub type slab_flags_t = ffi::c_uint;
pub type fmode_t = ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct atomic_t {
    pub counter: ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct atomic64_t {
    pub counter: s64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rcuref_t {
    pub refcnt: atomic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
impl Default for list_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
impl Default for hlist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
impl Default for hlist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
}
impl Default for callback_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcuwait {
    pub task: *mut task_struct,
}
impl Default for rcuwait {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_system_type {
    pub name: *const ffi::c_char,
    pub fs_flags: ffi::c_int,
    pub init_fs_context:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context) -> ffi::c_int>,
    pub parameters: *const fs_parameter_spec,
    pub mount: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_system_type,
            arg2: ffi::c_int,
            arg3: *const ffi::c_char,
            arg4: *mut ffi::c_void,
        ) -> *mut dentry,
    >,
    pub kill_sb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub owner: *mut module,
    pub next: *mut file_system_type,
    pub fs_supers: hlist_head,
    pub s_lock_key: lock_class_key,
    pub s_umount_key: lock_class_key,
    pub s_vfs_rename_key: lock_class_key,
    pub s_writers_key: [lock_class_key; 3usize],
    pub i_lock_key: lock_class_key,
    pub i_mutex_key: lock_class_key,
    pub invalidate_lock_key: lock_class_key,
    pub i_mutex_dir_key: lock_class_key,
}
impl Default for file_system_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct module {
    pub state: module_state,
    pub list: list_head,
    pub name: [ffi::c_char; 56usize],
    pub mkobj: module_kobject,
    pub modinfo_attrs: *mut module_attribute,
    pub version: *const ffi::c_char,
    pub srcversion: *const ffi::c_char,
    pub holders_dir: *mut kobject,
    pub syms: *mut kernel_symbol,
    pub crcs: *const u32_,
    pub num_syms: ffi::c_uint,
    pub param_lock: mutex,
    pub kp: *mut kernel_param,
    pub num_kp: ffi::c_uint,
    pub num_gpl_syms: ffi::c_uint,
    pub gpl_syms: *const kernel_symbol,
    pub gpl_crcs: *const u32_,
    pub using_gplonly_symbols: bool_,
    pub async_probe_requested: bool_,
    pub num_exentries: ffi::c_uint,
    pub extable: *mut exception_table_entry,
    pub init: ::core::option::Option<unsafe extern "C" fn() -> ffi::c_int>,
    pub mem: [module_memory; 7usize],
    pub arch: mod_arch_specific,
    pub taints: ffi::c_ulong,
    pub num_bugs: ffi::c_uint,
    pub bug_list: list_head,
    pub bug_table: *mut bug_entry,
    pub kallsyms: *mut mod_kallsyms,
    pub core_kallsyms: mod_kallsyms,
    pub sect_attrs: *mut module_sect_attrs,
    pub notes_attrs: *mut module_notes_attrs,
    pub args: *mut ffi::c_char,
    pub percpu: *mut ffi::c_void,
    pub percpu_size: ffi::c_uint,
    pub noinstr_text_start: *mut ffi::c_void,
    pub noinstr_text_size: ffi::c_uint,
    pub num_tracepoints: ffi::c_uint,
    pub tracepoints_ptrs: *const ffi::c_int,
    pub num_srcu_structs: ffi::c_uint,
    pub srcu_struct_ptrs: *mut *mut srcu_struct,
    pub jump_entries: *mut jump_entry,
    pub num_jump_entries: ffi::c_uint,
    pub num_trace_bprintk_fmt: ffi::c_uint,
    pub trace_bprintk_fmt_start: *mut *const ffi::c_char,
    pub trace_events: *mut *mut trace_event_call,
    pub num_trace_events: ffi::c_uint,
    pub trace_evals: *mut *mut trace_eval_map,
    pub num_trace_evals: ffi::c_uint,
    pub kprobes_text_start: *mut ffi::c_void,
    pub kprobes_text_size: ffi::c_uint,
    pub kprobe_blacklist: *mut ffi::c_ulong,
    pub num_kprobe_blacklist: ffi::c_uint,
    pub num_static_call_sites: ffi::c_int,
    pub static_call_sites: *mut static_call_site,
    pub source_list: list_head,
    pub target_list: list_head,
    pub exit: ::core::option::Option<unsafe extern "C" fn()>,
    pub refcnt: atomic_t,
}
impl Default for module {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qspinlock {
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qspinlock__bindgen_ty_1 {
    pub val: atomic_t,
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: qspinlock__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_1 {
    pub locked: u8_,
    pub pending: u8_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_2 {
    pub locked_pending: u16_,
    pub tail: u16_,
}
impl Default for qspinlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for qspinlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arch_spinlock_t = qspinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qrwlock {
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1,
    pub wait_lock: arch_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qrwlock__bindgen_ty_1 {
    pub cnts: atomic_t,
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qrwlock__bindgen_ty_1__bindgen_ty_1 {
    pub wlocked: u8_,
    pub __lstate: [u8_; 3usize],
}
impl Default for qrwlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for qrwlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type arch_rwlock_t = qrwlock;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lock_class_key {}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lockdep_map {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
}
impl Default for raw_spinlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type raw_spinlock_t = raw_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ratelimit_state {
    pub lock: raw_spinlock_t,
    pub interval: ffi::c_int,
    pub burst: ffi::c_int,
    pub rs_n_left: atomic_t,
    pub missed: atomic_t,
    pub flags: ffi::c_uint,
    pub begin: ffi::c_ulong,
}
impl Default for ratelimit_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_operations {
    pub owner: *mut module,
    pub fop_flags: fop_flags_t,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: loff_t, arg3: ffi::c_int) -> loff_t,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut ffi::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *const ffi::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub read_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub write_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub iopoll: ::core::option::Option<
        unsafe extern "C" fn(
            kiocb: *mut kiocb,
            arg1: *mut io_comp_batch,
            flags: ffi::c_uint,
        ) -> ffi::c_int,
    >,
    pub iterate_shared: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> ffi::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
    pub unlocked_ioctl: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: ffi::c_uint, arg3: ffi::c_ulong) -> ffi::c_long,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: ffi::c_uint, arg3: ffi::c_ulong) -> ffi::c_long,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut vm_area_struct) -> ffi::c_int,
    >,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ffi::c_int,
    >,
    pub flush:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file, id: fl_owner_t) -> ffi::c_int>,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ffi::c_int,
    >,
    pub fsync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            datasync: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub fasync: ::core::option::Option<
        unsafe extern "C" fn(arg1: ffi::c_int, arg2: *mut file, arg3: ffi::c_int) -> ffi::c_int,
    >,
    pub lock: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: ffi::c_int, arg3: *mut file_lock) -> ffi::c_int,
    >,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ffi::c_ulong,
            arg3: ffi::c_ulong,
            arg4: ffi::c_ulong,
            arg5: ffi::c_ulong,
        ) -> ffi::c_ulong,
    >,
    pub check_flags: ::core::option::Option<unsafe extern "C" fn(arg1: ffi::c_int) -> ffi::c_int>,
    pub flock: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: ffi::c_int, arg3: *mut file_lock) -> ffi::c_int,
    >,
    pub splice_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pipe_inode_info,
            arg2: *mut file,
            arg3: *mut loff_t,
            arg4: usize,
            arg5: ffi::c_uint,
        ) -> isize,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut loff_t,
            arg3: *mut pipe_inode_info,
            arg4: usize,
            arg5: ffi::c_uint,
        ) -> isize,
    >,
    pub splice_eof: ::core::option::Option<unsafe extern "C" fn(file: *mut file)>,
    pub setlease: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ffi::c_int,
            arg3: *mut *mut file_lease,
            arg4: *mut *mut ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub fallocate: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            mode: ffi::c_int,
            offset: loff_t,
            len: loff_t,
        ) -> ffi::c_long,
    >,
    pub show_fdinfo: ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, f: *mut file)>,
    pub copy_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: usize,
            arg6: ffi::c_uint,
        ) -> isize,
    >,
    pub remap_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            file_in: *mut file,
            pos_in: loff_t,
            file_out: *mut file,
            pos_out: loff_t,
            len: loff_t,
            remap_flags: ffi::c_uint,
        ) -> loff_t,
    >,
    pub fadvise: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            arg4: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub uring_cmd: ::core::option::Option<
        unsafe extern "C" fn(ioucmd: *mut io_uring_cmd, issue_flags: ffi::c_uint) -> ffi::c_int,
    >,
    pub uring_cmd_iopoll: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut io_uring_cmd,
            arg2: *mut io_comp_batch,
            poll_flags: ffi::c_uint,
        ) -> ffi::c_int,
    >,
    pub mmap_prepare:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut vm_area_desc) -> ffi::c_int>,
}
impl Default for file_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bug_entry {
    pub bug_addr_disp: ffi::c_int,
    pub file_disp: ffi::c_int,
    pub line: ffi::c_ushort,
    pub flags: ffi::c_ushort,
}
unsafe extern "C" {
    pub fn generic_bug_clear_once();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct static_call_site {
    pub addr: s32,
    pub key: s32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct jump_entry {
    pub code: s32,
    pub target: s32,
    pub key: ffi::c_long,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct orc_entry {
    pub sp_offset: s16,
    pub bp_offset: s16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl orc_entry {
    #[inline]
    pub fn sp_reg(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sp_reg(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sp_reg_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sp_reg_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bp_reg(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_bp_reg(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bp_reg_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bp_reg_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn type__raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_type_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn signal(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_signal(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn signal_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_signal_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sp_reg: ffi::c_uint,
        bp_reg: ffi::c_uint,
        type_: ffi::c_uint,
        signal: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sp_reg: u32 = unsafe { ::core::mem::transmute(sp_reg) };
            sp_reg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let bp_reg: u32 = unsafe { ::core::mem::transmute(bp_reg) };
            bp_reg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let signal: u32 = unsafe { ::core::mem::transmute(signal) };
            signal as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    _unused: [u8; 0],
}
pub const timespec_type_TT_NONE: timespec_type = 0;
pub const timespec_type_TT_NATIVE: timespec_type = 1;
pub const timespec_type_TT_COMPAT: timespec_type = 2;
pub type timespec_type = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block {
    pub arch_data: ffi::c_ulong,
    pub fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut restart_block) -> ffi::c_long>,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1 {
    pub futex: restart_block__bindgen_ty_1__bindgen_ty_1,
    pub nanosleep: restart_block__bindgen_ty_1__bindgen_ty_2,
    pub poll: restart_block__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_1 {
    pub uaddr: *mut u32_,
    pub val: u32_,
    pub flags: u32_,
    pub bitset: u32_,
    pub time: u64_,
    pub uaddr2: *mut u32_,
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_2 {
    pub clockid: clockid_t,
    pub type_: timespec_type,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub expires: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub rmtp: *mut __kernel_timespec,
    pub compat_rmtp: *mut old_timespec32,
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_3 {
    pub ufds: *mut pollfd,
    pub nfds: ffi::c_int,
    pub has_timeout: ffi::c_int,
    pub tv_sec: ffi::c_ulong,
    pub tv_nsec: ffi::c_ulong,
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for restart_block__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for restart_block {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct cacheline_padding {
    pub x: __IncompleteArrayField<ffi::c_char>,
}
impl Default for cacheline_padding {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct range {
    pub start: u64_,
    pub end: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_bitmap {
    _unused: [u8; 0],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct desc_struct {
    pub limit0: u16_,
    pub base0: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl desc_struct {
    #[inline]
    pub fn base1(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn base1_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_base1_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn type_(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn type__raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_type_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn s(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn s_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_s_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dpl(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dpl_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_dpl_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn p(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn p_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_p_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn limit1(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_limit1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn limit1_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                4u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_limit1_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn avl(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_avl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn avl_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_avl_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_l(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_l_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn d(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_d(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn d_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                22usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_d_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                22usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn g(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_g(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn g_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_g_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn base2(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base2(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn base2_raw(this: *const Self) -> u16_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_base2_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        base1: u16_,
        type_: u16_,
        s: u16_,
        dpl: u16_,
        p: u16_,
        limit1: u16_,
        avl: u16_,
        l: u16_,
        d: u16_,
        g: u16_,
        base2: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let base1: u16 = unsafe { ::core::mem::transmute(base1) };
            base1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let type_: u16 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let s: u16 = unsafe { ::core::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u16 = unsafe { ::core::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u16 = unsafe { ::core::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let limit1: u16 = unsafe { ::core::mem::transmute(limit1) };
            limit1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let avl: u16 = unsafe { ::core::mem::transmute(avl) };
            avl as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let l: u16 = unsafe { ::core::mem::transmute(l) };
            l as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let d: u16 = unsafe { ::core::mem::transmute(d) };
            d as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let g: u16 = unsafe { ::core::mem::transmute(g) };
            g as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let base2: u16 = unsafe { ::core::mem::transmute(base2) };
            base2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type pteval_t = ffi::c_ulong;
pub type pmdval_t = ffi::c_ulong;
pub type pudval_t = ffi::c_ulong;
pub type pgdval_t = ffi::c_ulong;
pub type pgprotval_t = ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pte_t {
    pub pte: pteval_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pmd_t {
    pub pmd: pmdval_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pgprot {
    pub pgprot: pgprotval_t,
}
pub type pgprot_t = pgprot;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pgd_t {
    pub pgd: pgdval_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pud_t {
    pub pud: pudval_t,
}
pub type pgtable_t = *mut page;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seq_operations {
    pub start: ::core::option::Option<
        unsafe extern "C" fn(m: *mut seq_file, pos: *mut loff_t) -> *mut ffi::c_void,
    >,
    pub stop: ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, v: *mut ffi::c_void)>,
    pub next: ::core::option::Option<
        unsafe extern "C" fn(
            m: *mut seq_file,
            v: *mut ffi::c_void,
            pos: *mut loff_t,
        ) -> *mut ffi::c_void,
    >,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(m: *mut seq_file, v: *mut ffi::c_void) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_event {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_struct {
    pub tls_array: [desc_struct; 3usize],
    pub sp: ffi::c_ulong,
    pub es: ffi::c_ushort,
    pub ds: ffi::c_ushort,
    pub fsindex: ffi::c_ushort,
    pub gsindex: ffi::c_ushort,
    pub fsbase: ffi::c_ulong,
    pub gsbase: ffi::c_ulong,
    pub ptrace_bps: [*mut perf_event; 4usize],
    pub virtual_dr6: ffi::c_ulong,
    pub ptrace_dr7: ffi::c_ulong,
    pub cr2: ffi::c_ulong,
    pub trap_nr: ffi::c_ulong,
    pub error_code: ffi::c_ulong,
    pub io_bitmap: *mut io_bitmap,
    pub iopl_emul: ffi::c_ulong,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub pkru: u32_,
}
impl Default for thread_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl thread_struct {
    #[inline]
    pub fn iopl_warn(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_iopl_warn(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn iopl_warn_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_iopl_warn_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(iopl_warn: ffi::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let iopl_warn: u32 = unsafe { ::core::mem::transmute(iopl_warn) };
            iopl_warn as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type atomic_long_t = atomic64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct thread_info {
    pub flags: ffi::c_ulong,
    pub syscall_work: ffi::c_ulong,
    pub status: u32_,
    pub cpu: u32_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cpumask {
    pub bits: [ffi::c_ulong; 1usize],
}
pub type cpumask_t = cpumask;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nodemask_t {
    pub bits: [ffi::c_ulong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llist_head {
    pub first: *mut llist_node,
}
impl Default for llist_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llist_node {
    pub next: *mut llist_node,
}
impl Default for llist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_node {
    pub llist: llist_node,
    pub __bindgen_anon_1: __call_single_node__bindgen_ty_1,
    pub src: u16_,
    pub dst: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __call_single_node__bindgen_ty_1 {
    pub u_flags: ffi::c_uint,
    pub a_flags: atomic_t,
}
impl Default for __call_single_node__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __call_single_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type smp_call_func_t = ::core::option::Option<unsafe extern "C" fn(info: *mut ffi::c_void)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_data {
    pub node: __call_single_node,
    pub func: smp_call_func_t,
    pub info: *mut ffi::c_void,
}
impl Default for __call_single_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type call_single_data_t = __call_single_data;
unsafe extern "C" {
    pub fn generic_smp_call_function_single_interrupt();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spinlock {
    pub __bindgen_anon_1: spinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spinlock__bindgen_ty_1 {
    pub rlock: raw_spinlock,
}
impl Default for spinlock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for spinlock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rwlock_t {
    pub raw_lock: arch_rwlock_t,
}
impl Default for rwlock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_head {
    pub lock: spinlock_t,
    pub head: list_head,
}
impl Default for wait_queue_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type wait_queue_head_t = wait_queue_head;
pub const pid_type_PIDTYPE_PID: pid_type = 0;
pub const pid_type_PIDTYPE_TGID: pid_type = 1;
pub const pid_type_PIDTYPE_PGID: pid_type = 2;
pub const pid_type_PIDTYPE_SID: pid_type = 3;
pub const pid_type_PIDTYPE_MAX: pid_type = 4;
pub type pid_type = ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pid_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sem_undo_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysv_sem {
    pub undo_list: *mut sem_undo_list,
}
impl Default for sysv_sem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysv_shm {
    pub shm_clist: list_head,
}
impl Default for sysv_shm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct optimistic_spin_queue {
    pub tail: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mutex {
    pub owner: atomic_long_t,
    pub wait_lock: raw_spinlock_t,
    pub osq: optimistic_spin_queue,
    pub wait_list: list_head,
}
impl Default for mutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plist_node {
    pub prio: ffi::c_int,
    pub prio_list: list_head,
    pub node_list: list_head,
}
impl Default for plist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_node {
    pub __rb_parent_color: ffi::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
impl Default for rb_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root {
    pub rb_node: *mut rb_node,
}
impl Default for rb_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root_cached {
    pub rb_root: rb_root,
    pub rb_leftmost: *mut rb_node,
}
impl Default for rb_root_cached {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timerqueue_node {
    pub node: rb_node,
    pub expires: ktime_t,
}
impl Default for timerqueue_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timerqueue_head {
    pub rb_root: rb_root_cached,
}
impl Default for timerqueue_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const hrtimer_restart_HRTIMER_NORESTART: hrtimer_restart = 0;
pub const hrtimer_restart_HRTIMER_RESTART: hrtimer_restart = 1;
pub type hrtimer_restart = ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hrtimer {
    pub node: timerqueue_node,
    pub _softexpires: ktime_t,
    pub function:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut hrtimer) -> hrtimer_restart>,
    pub base: *mut hrtimer_clock_base,
    pub state: u8_,
    pub is_rel: u8_,
    pub is_soft: u8_,
    pub is_hard: u8_,
}
impl Default for hrtimer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_list {
    pub entry: hlist_node,
    pub expires: ffi::c_ulong,
    pub function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
    pub flags: u32_,
}
impl Default for timer_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp_filter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp {
    pub mode: ffi::c_int,
    pub filter_count: atomic_t,
    pub filter: *mut seccomp_filter,
}
impl Default for seccomp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct refcount_struct {
    pub refs: atomic_t,
}
pub type refcount_t = refcount_struct;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_timespec {
    pub tv_sec: __kernel_time64_t,
    pub tv_nsec: ffi::c_longlong,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: __kernel_ulong_t,
    pub rlim_max: __kernel_ulong_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct task_cputime {
    pub stime: u64_,
    pub utime: u64_,
    pub sum_exec_runtime: ffi::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sigset_t {
    pub sig: [ffi::c_ulong; 1usize],
}
pub type __signalfn_t = ::core::option::Option<unsafe extern "C" fn(arg1: ffi::c_int)>;
pub type __sighandler_t = __signalfn_t;
pub type __restorefn_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type __sigrestore_t = __restorefn_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ffi::c_int,
    pub sival_ptr: *mut ffi::c_void,
}
impl Default for sigval {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields {
    pub _kill: __sifields__bindgen_ty_1,
    pub _timer: __sifields__bindgen_ty_2,
    pub _rt: __sifields__bindgen_ty_3,
    pub _sigchld: __sifields__bindgen_ty_4,
    pub _sigfault: __sifields__bindgen_ty_5,
    pub _sigpoll: __sifields__bindgen_ty_6,
    pub _sigsys: __sifields__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_1 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_2 {
    pub _tid: __kernel_timer_t,
    pub _overrun: ffi::c_int,
    pub _sigval: sigval_t,
    pub _sys_private: ffi::c_int,
}
impl Default for __sifields__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_3 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _sigval: sigval_t,
}
impl Default for __sifields__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_4 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _status: ffi::c_int,
    pub _utime: __kernel_clock_t,
    pub _stime: __kernel_clock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_5 {
    pub _addr: *mut ffi::c_void,
    pub __bindgen_anon_1: __sifields__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields__bindgen_ty_5__bindgen_ty_1 {
    pub _trapno: ffi::c_int,
    pub _addr_lsb: ffi::c_short,
    pub _addr_bnd: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
    pub _perf: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [ffi::c_char; 8usize],
    pub _lower: *mut ffi::c_void,
    pub _upper: *mut ffi::c_void,
}
impl Default for __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [ffi::c_char; 8usize],
    pub _pkey: __u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
    pub _data: ffi::c_ulong,
    pub _type: __u32,
    pub _flags: __u32,
}
impl Default for __sifields__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __sifields__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_6 {
    pub _band: ffi::c_long,
    pub _fd: ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_7 {
    pub _call_addr: *mut ffi::c_void,
    pub _syscall: ffi::c_int,
    pub _arch: ffi::c_uint,
}
impl Default for __sifields__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __sifields {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo {
    pub __bindgen_anon_1: kernel_siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo__bindgen_ty_1 {
    pub si_signo: ffi::c_int,
    pub si_errno: ffi::c_int,
    pub si_code: ffi::c_int,
    pub _sifields: __sifields,
}
impl Default for kernel_siginfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kernel_siginfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type kernel_siginfo_t = kernel_siginfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigpending {
    pub list: list_head,
    pub signal: sigset_t,
}
impl Default for sigpending {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: __sighandler_t,
    pub sa_flags: ffi::c_ulong,
    pub sa_restorer: __sigrestore_t,
    pub sa_mask: sigset_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct k_sigaction {
    pub sa: sigaction,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct syscall_user_dispatch {
    pub selector: *mut ffi::c_char,
    pub offset: ffi::c_ulong,
    pub len: ffi::c_ulong,
    pub on_dispatch: bool_,
}
impl Default for syscall_user_dispatch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct arch_tlbflush_unmap_batch {
    pub cpumask: cpumask,
    pub unmapped_pages: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_frag {
    pub page: *mut page,
    pub offset: __u32,
    pub size: __u32,
}
impl Default for page_frag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tlbflush_unmap_batch {
    pub arch: arch_tlbflush_unmap_batch,
    pub flush_required: bool_,
    pub writable: bool_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct task_io_accounting {
    pub rchar: u64_,
    pub wchar: u64_,
    pub syscr: u64_,
    pub syscw: u64_,
    pub read_bytes: u64_,
    pub write_bytes: u64_,
    pub cancelled_write_bytes: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cputimer_base {
    pub nextevt: u64_,
    pub tqhead: timerqueue_head,
}
impl Default for posix_cputimer_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cputimers {
    pub bases: [posix_cputimer_base; 3usize],
    pub timers_active: ffi::c_uint,
    pub expiry_active: ffi::c_uint,
}
impl Default for posix_cputimers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_cputimers_work {
    pub work: callback_head,
    pub mutex: mutex,
    pub scheduled: ffi::c_uint,
}
impl Default for posix_cputimers_work {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Default)]
pub struct rseq {
    pub cpu_id_start: __u32,
    pub cpu_id: __u32,
    pub rseq_cs: __u64,
    pub flags: __u32,
    pub node_id: __u32,
    pub mm_cid: __u32,
    pub end: __IncompleteArrayField<ffi::c_char>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seqcount {
    pub sequence: ffi::c_uint,
}
pub type seqcount_t = seqcount;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seqcount_raw_spinlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_raw_spinlock_t = seqcount_raw_spinlock;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct seqcount_spinlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_spinlock_t = seqcount_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seqlock_t {
    pub seqcount: seqcount_spinlock_t,
    pub lock: spinlock_t,
}
impl Default for seqlock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kuid_t {
    pub val: uid_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kgid_t {
    pub val: gid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_plug {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_net_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct capture_control {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfs_rq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct futex_pi_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_uring_task {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mempolicy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nameidata {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_event_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_ctx_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pipe_inode_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reclaim_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct robust_list_head {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_delay_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prev_cputime {
    pub utime: u64_,
    pub stime: u64_,
    pub lock: raw_spinlock_t,
}
impl Default for prev_cputime {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_info {
    pub pcount: ffi::c_ulong,
    pub run_delay: ffi::c_ulonglong,
    pub max_run_delay: ffi::c_ulonglong,
    pub min_run_delay: ffi::c_ulonglong,
    pub last_arrival: ffi::c_ulonglong,
    pub last_queued: ffi::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct load_weight {
    pub weight: ffi::c_ulong,
    pub inv_weight: u32_,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct sched_avg {
    pub last_update_time: u64_,
    pub load_sum: u64_,
    pub runnable_sum: u64_,
    pub util_sum: u32_,
    pub period_contrib: u32_,
    pub load_avg: ffi::c_ulong,
    pub runnable_avg: ffi::c_ulong,
    pub util_avg: ffi::c_ulong,
    pub util_est: ffi::c_uint,
}
impl Default for sched_avg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct sched_statistics {
    pub wait_start: u64_,
    pub wait_max: u64_,
    pub wait_count: u64_,
    pub wait_sum: u64_,
    pub iowait_count: u64_,
    pub iowait_sum: u64_,
    pub sleep_start: u64_,
    pub sleep_max: u64_,
    pub sum_sleep_runtime: s64,
    pub block_start: u64_,
    pub block_max: u64_,
    pub sum_block_runtime: s64,
    pub exec_max: s64,
    pub slice_max: u64_,
    pub nr_migrations_cold: u64_,
    pub nr_failed_migrations_affine: u64_,
    pub nr_failed_migrations_running: u64_,
    pub nr_failed_migrations_hot: u64_,
    pub nr_forced_migrations: u64_,
    pub nr_wakeups: u64_,
    pub nr_wakeups_sync: u64_,
    pub nr_wakeups_migrate: u64_,
    pub nr_wakeups_local: u64_,
    pub nr_wakeups_remote: u64_,
    pub nr_wakeups_affine: u64_,
    pub nr_wakeups_affine_attempts: u64_,
    pub nr_wakeups_passive: u64_,
    pub nr_wakeups_idle: u64_,
}
impl Default for sched_statistics {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_entity {
    pub load: load_weight,
    pub run_node: rb_node,
    pub deadline: u64_,
    pub min_vruntime: u64_,
    pub min_slice: u64_,
    pub group_node: list_head,
    pub on_rq: ffi::c_uchar,
    pub sched_delayed: ffi::c_uchar,
    pub rel_deadline: ffi::c_uchar,
    pub custom_slice: ffi::c_uchar,
    pub exec_start: u64_,
    pub sum_exec_runtime: u64_,
    pub prev_sum_exec_runtime: u64_,
    pub vruntime: u64_,
    pub __bindgen_anon_1: sched_entity__bindgen_ty_1,
    pub slice: u64_,
    pub nr_migrations: u64_,
    pub depth: ffi::c_int,
    pub parent: *mut sched_entity,
    pub cfs_rq: *mut cfs_rq,
    pub my_q: *mut cfs_rq,
    pub runnable_weight: ffi::c_ulong,
    pub __bindgen_padding_0: u64,
    pub avg: sched_avg,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sched_entity__bindgen_ty_1 {
    pub vlag: s64,
    pub vprot: u64_,
}
impl Default for sched_entity__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sched_entity {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_rt_entity {
    pub run_list: list_head,
    pub timeout: ffi::c_ulong,
    pub watchdog_stamp: ffi::c_ulong,
    pub time_slice: ffi::c_uint,
    pub on_rq: ffi::c_ushort,
    pub on_list: ffi::c_ushort,
    pub back: *mut sched_rt_entity,
}
impl Default for sched_rt_entity {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type dl_server_pick_f =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut sched_dl_entity) -> *mut task_struct>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_dl_entity {
    pub rb_node: rb_node,
    pub dl_runtime: u64_,
    pub dl_deadline: u64_,
    pub dl_period: u64_,
    pub dl_bw: u64_,
    pub dl_density: u64_,
    pub runtime: s64,
    pub deadline: u64_,
    pub flags: ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub dl_timer: hrtimer,
    pub inactive_timer: hrtimer,
    pub rq: *mut rq,
    pub server_pick_task: dl_server_pick_f,
    pub pi_se: *mut sched_dl_entity,
}
impl Default for sched_dl_entity {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl sched_dl_entity {
    #[inline]
    pub fn dl_throttled(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_throttled(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_throttled_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_throttled_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_yielded(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_yielded(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_yielded_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_yielded_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_non_contending(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_non_contending(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_non_contending_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_non_contending_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_overrun(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_overrun(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_overrun_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_overrun_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_server(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_server(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_server_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_server_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_server_active(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_server_active(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_server_active_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_server_active_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_defer(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_defer(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_defer_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_defer_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_defer_armed(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_defer_armed(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_defer_armed_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_defer_armed_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dl_defer_running(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_defer_running(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dl_defer_running_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dl_defer_running_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dl_throttled: ffi::c_uint,
        dl_yielded: ffi::c_uint,
        dl_non_contending: ffi::c_uint,
        dl_overrun: ffi::c_uint,
        dl_server: ffi::c_uint,
        dl_server_active: ffi::c_uint,
        dl_defer: ffi::c_uint,
        dl_defer_armed: ffi::c_uint,
        dl_defer_running: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dl_throttled: u32 = unsafe { ::core::mem::transmute(dl_throttled) };
            dl_throttled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dl_yielded: u32 = unsafe { ::core::mem::transmute(dl_yielded) };
            dl_yielded as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dl_non_contending: u32 = unsafe { ::core::mem::transmute(dl_non_contending) };
            dl_non_contending as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dl_overrun: u32 = unsafe { ::core::mem::transmute(dl_overrun) };
            dl_overrun as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dl_server: u32 = unsafe { ::core::mem::transmute(dl_server) };
            dl_server as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dl_server_active: u32 = unsafe { ::core::mem::transmute(dl_server_active) };
            dl_server_active as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let dl_defer: u32 = unsafe { ::core::mem::transmute(dl_defer) };
            dl_defer as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dl_defer_armed: u32 = unsafe { ::core::mem::transmute(dl_defer_armed) };
            dl_defer_armed as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dl_defer_running: u32 = unsafe { ::core::mem::transmute(dl_defer_running) };
            dl_defer_running as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rcu_special {
    pub b: rcu_special__bindgen_ty_1,
    pub s: u32_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rcu_special__bindgen_ty_1 {
    pub blocked: u8_,
    pub need_qs: u8_,
    pub exp_hint: u8_,
    pub need_mb: u8_,
}
impl Default for rcu_special {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wake_q_node {
    pub next: *mut wake_q_node,
}
impl Default for wake_q_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kmap_ctrl {}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct task_struct {
    pub thread_info: thread_info,
    pub __state: ffi::c_uint,
    pub saved_state: ffi::c_uint,
    pub stack: *mut ffi::c_void,
    pub usage: refcount_t,
    pub flags: ffi::c_uint,
    pub ptrace: ffi::c_uint,
    pub on_cpu: ffi::c_int,
    pub wake_entry: __call_single_node,
    pub wakee_flips: ffi::c_uint,
    pub wakee_flip_decay_ts: ffi::c_ulong,
    pub last_wakee: *mut task_struct,
    pub recent_used_cpu: ffi::c_int,
    pub wake_cpu: ffi::c_int,
    pub on_rq: ffi::c_int,
    pub prio: ffi::c_int,
    pub static_prio: ffi::c_int,
    pub normal_prio: ffi::c_int,
    pub rt_priority: ffi::c_uint,
    pub __bindgen_padding_0: [u64; 0usize],
    pub se: sched_entity,
    pub rt: sched_rt_entity,
    pub dl: sched_dl_entity,
    pub dl_server: *mut sched_dl_entity,
    pub sched_class: *mut sched_class,
    pub sched_task_group: *mut task_group,
    pub __bindgen_padding_1: u64,
    pub stats: sched_statistics,
    pub btrace_seq: ffi::c_uint,
    pub policy: ffi::c_uint,
    pub max_allowed_capacity: ffi::c_ulong,
    pub nr_cpus_allowed: ffi::c_int,
    pub cpus_ptr: *const cpumask_t,
    pub user_cpus_ptr: *mut cpumask_t,
    pub cpus_mask: cpumask_t,
    pub migration_pending: *mut ffi::c_void,
    pub migration_disabled: ffi::c_ushort,
    pub migration_flags: ffi::c_ushort,
    pub rcu_read_lock_nesting: ffi::c_int,
    pub rcu_read_unlock_special: rcu_special,
    pub rcu_node_entry: list_head,
    pub rcu_blocked_node: *mut rcu_node,
    pub rcu_tasks_nvcsw: ffi::c_ulong,
    pub rcu_tasks_holdout: u8_,
    pub rcu_tasks_idx: u8_,
    pub rcu_tasks_idle_cpu: ffi::c_int,
    pub rcu_tasks_holdout_list: list_head,
    pub rcu_tasks_exit_cpu: ffi::c_int,
    pub rcu_tasks_exit_list: list_head,
    pub trc_reader_nesting: ffi::c_int,
    pub trc_ipi_to_cpu: ffi::c_int,
    pub trc_reader_special: rcu_special,
    pub trc_holdout_list: list_head,
    pub trc_blkd_node: list_head,
    pub trc_blkd_cpu: ffi::c_int,
    pub sched_info: sched_info,
    pub tasks: list_head,
    pub pushable_tasks: plist_node,
    pub pushable_dl_tasks: rb_node,
    pub mm: *mut mm_struct,
    pub active_mm: *mut mm_struct,
    pub faults_disabled_mapping: *mut address_space,
    pub exit_state: ffi::c_int,
    pub exit_code: ffi::c_int,
    pub exit_signal: ffi::c_int,
    pub pdeath_signal: ffi::c_int,
    pub jobctl: ffi::c_ulong,
    pub personality: ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize]>,
    pub atomic_flags: ffi::c_ulong,
    pub restart_block: restart_block,
    pub pid: pid_t,
    pub tgid: pid_t,
    pub stack_canary: ffi::c_ulong,
    pub real_parent: *mut task_struct,
    pub parent: *mut task_struct,
    pub children: list_head,
    pub sibling: list_head,
    pub group_leader: *mut task_struct,
    pub ptraced: list_head,
    pub ptrace_entry: list_head,
    pub thread_pid: *mut pid,
    pub pid_links: [hlist_node; 4usize],
    pub thread_node: list_head,
    pub vfork_done: *mut completion,
    pub set_child_tid: *mut ffi::c_int,
    pub clear_child_tid: *mut ffi::c_int,
    pub worker_private: *mut ffi::c_void,
    pub utime: u64_,
    pub stime: u64_,
    pub gtime: u64_,
    pub prev_cputime: prev_cputime,
    pub nvcsw: ffi::c_ulong,
    pub nivcsw: ffi::c_ulong,
    pub start_time: u64_,
    pub start_boottime: u64_,
    pub min_flt: ffi::c_ulong,
    pub maj_flt: ffi::c_ulong,
    pub posix_cputimers: posix_cputimers,
    pub posix_cputimers_work: posix_cputimers_work,
    pub ptracer_cred: *const cred,
    pub real_cred: *const cred,
    pub cred: *const cred,
    pub cached_requested_key: *mut key,
    pub comm: [ffi::c_char; 16usize],
    pub nameidata: *mut nameidata,
    pub sysvsem: sysv_sem,
    pub sysvshm: sysv_shm,
    pub fs: *mut fs_struct,
    pub files: *mut files_struct,
    pub io_uring: *mut io_uring_task,
    pub nsproxy: *mut nsproxy,
    pub signal: *mut signal_struct,
    pub sighand: *mut sighand_struct,
    pub blocked: sigset_t,
    pub real_blocked: sigset_t,
    pub saved_sigmask: sigset_t,
    pub pending: sigpending,
    pub sas_ss_sp: ffi::c_ulong,
    pub sas_ss_size: usize,
    pub sas_ss_flags: ffi::c_uint,
    pub task_works: *mut callback_head,
    pub audit_context: *mut audit_context,
    pub loginuid: kuid_t,
    pub sessionid: ffi::c_uint,
    pub seccomp: seccomp,
    pub syscall_dispatch: syscall_user_dispatch,
    pub parent_exec_id: u64_,
    pub self_exec_id: u64_,
    pub alloc_lock: spinlock_t,
    pub pi_lock: raw_spinlock_t,
    pub wake_q: wake_q_node,
    pub pi_waiters: rb_root_cached,
    pub pi_top_task: *mut task_struct,
    pub pi_blocked_on: *mut rt_mutex_waiter,
    pub blocked_on: *mut mutex,
    pub journal_info: *mut ffi::c_void,
    pub bio_list: *mut bio_list,
    pub plug: *mut blk_plug,
    pub reclaim_state: *mut reclaim_state,
    pub io_context: *mut io_context,
    pub capture_control: *mut capture_control,
    pub ptrace_message: ffi::c_ulong,
    pub last_siginfo: *mut kernel_siginfo_t,
    pub ioac: task_io_accounting,
    pub acct_rss_mem1: u64_,
    pub acct_vm_mem1: u64_,
    pub acct_timexpd: u64_,
    pub mems_allowed: nodemask_t,
    pub mems_allowed_seq: seqcount_spinlock_t,
    pub cpuset_mem_spread_rotor: ffi::c_int,
    pub cgroups: *mut css_set,
    pub cg_list: list_head,
    pub robust_list: *mut robust_list_head,
    pub compat_robust_list: *mut compat_robust_list_head,
    pub pi_state_list: list_head,
    pub pi_state_cache: *mut futex_pi_state,
    pub futex_exit_mutex: mutex,
    pub futex_state: ffi::c_uint,
    pub perf_recursion: [u8_; 4usize],
    pub perf_event_ctxp: *mut perf_event_context,
    pub perf_event_mutex: mutex,
    pub perf_event_list: list_head,
    pub perf_ctx_data: *mut perf_ctx_data,
    pub mempolicy: *mut mempolicy,
    pub il_prev: ffi::c_short,
    pub il_weight: u8_,
    pub pref_node_fork: ffi::c_short,
    pub rseq: *mut rseq,
    pub rseq_len: u32_,
    pub rseq_sig: u32_,
    pub rseq_event_mask: ffi::c_ulong,
    pub mm_cid: ffi::c_int,
    pub last_mm_cid: ffi::c_int,
    pub migrate_from_cpu: ffi::c_int,
    pub mm_cid_active: ffi::c_int,
    pub cid_work: callback_head,
    pub tlb_ubc: tlbflush_unmap_batch,
    pub splice_pipe: *mut pipe_inode_info,
    pub task_frag: page_frag,
    pub delays: *mut task_delay_info,
    pub nr_dirtied: ffi::c_int,
    pub nr_dirtied_pause: ffi::c_int,
    pub dirty_paused_when: ffi::c_ulong,
    pub timer_slack_ns: u64_,
    pub default_timer_slack_ns: u64_,
    pub trace_recursion: ffi::c_ulong,
    pub throttle_disk: *mut gendisk,
    pub utask: *mut uprobe_task,
    pub kmap_ctrl: kmap_ctrl,
    pub rcu: callback_head,
    pub rcu_users: refcount_t,
    pub pagefault_disabled: ffi::c_int,
    pub oom_reaper_list: *mut task_struct,
    pub oom_reaper_timer: timer_list,
    pub stack_vm_area: *mut vm_struct,
    pub stack_refcount: refcount_t,
    pub security: *mut ffi::c_void,
    pub bpf_net_context: *mut bpf_net_context,
    pub mce_vaddr: *mut ffi::c_void,
    pub mce_kflags: __u64,
    pub mce_addr: u64_,
    pub _bitfield_align_2: [u64; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub mce_kill_me: callback_head,
    pub mce_count: ffi::c_int,
    pub kretprobe_instances: llist_head,
    pub rethooks: llist_head,
    pub l1d_flush_kill: callback_head,
    pub thread: thread_struct,
}
impl Default for task_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl task_struct {
    #[inline]
    pub fn sched_reset_on_fork(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_reset_on_fork(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sched_reset_on_fork_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sched_reset_on_fork_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sched_contributes_to_load(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_contributes_to_load(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sched_contributes_to_load_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sched_contributes_to_load_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sched_migrated(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_migrated(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sched_migrated_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sched_migrated_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sched_task_hot(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_task_hot(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sched_task_hot_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sched_task_hot_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sched_remote_wakeup(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_remote_wakeup(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sched_remote_wakeup_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sched_remote_wakeup_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sched_rt_mutex(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_rt_mutex(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sched_rt_mutex_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sched_rt_mutex_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_execve(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_execve(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_execve_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_execve_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_iowait(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_iowait(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_iowait_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                35usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_iowait_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn restore_sigmask(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restore_sigmask(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn restore_sigmask_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                36usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_restore_sigmask_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                36usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_cgroup_migration(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_migration(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_cgroup_migration_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                37usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_no_cgroup_migration_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                37usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn frozen(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn frozen_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                38usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_frozen_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                38usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_memdelay(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_memdelay(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_memdelay_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                39usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_memdelay_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                39usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_eventfd(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_eventfd(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_eventfd_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_eventfd_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pasid_activated(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pasid_activated(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pasid_activated_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                41usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pasid_activated_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                41usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reported_split_lock(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reported_split_lock(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reported_split_lock_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                42usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reported_split_lock_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                42usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_thrashing(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_thrashing(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_thrashing_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                43usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_thrashing_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                43usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_nf_duplicate(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_nf_duplicate(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_nf_duplicate_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 6usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                44usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_nf_duplicate_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 6usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                44usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sched_reset_on_fork: ffi::c_uint,
        sched_contributes_to_load: ffi::c_uint,
        sched_migrated: ffi::c_uint,
        sched_task_hot: ffi::c_uint,
        sched_remote_wakeup: ffi::c_uint,
        sched_rt_mutex: ffi::c_uint,
        in_execve: ffi::c_uint,
        in_iowait: ffi::c_uint,
        restore_sigmask: ffi::c_uint,
        no_cgroup_migration: ffi::c_uint,
        frozen: ffi::c_uint,
        use_memdelay: ffi::c_uint,
        in_eventfd: ffi::c_uint,
        pasid_activated: ffi::c_uint,
        reported_split_lock: ffi::c_uint,
        in_thrashing: ffi::c_uint,
        in_nf_duplicate: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 6usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sched_reset_on_fork: u32 = unsafe { ::core::mem::transmute(sched_reset_on_fork) };
            sched_reset_on_fork as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sched_contributes_to_load: u32 =
                unsafe { ::core::mem::transmute(sched_contributes_to_load) };
            sched_contributes_to_load as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sched_migrated: u32 = unsafe { ::core::mem::transmute(sched_migrated) };
            sched_migrated as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sched_task_hot: u32 = unsafe { ::core::mem::transmute(sched_task_hot) };
            sched_task_hot as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let sched_remote_wakeup: u32 = unsafe { ::core::mem::transmute(sched_remote_wakeup) };
            sched_remote_wakeup as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let sched_rt_mutex: u32 = unsafe { ::core::mem::transmute(sched_rt_mutex) };
            sched_rt_mutex as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let in_execve: u32 = unsafe { ::core::mem::transmute(in_execve) };
            in_execve as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let in_iowait: u32 = unsafe { ::core::mem::transmute(in_iowait) };
            in_iowait as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let restore_sigmask: u32 = unsafe { ::core::mem::transmute(restore_sigmask) };
            restore_sigmask as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let no_cgroup_migration: u32 = unsafe { ::core::mem::transmute(no_cgroup_migration) };
            no_cgroup_migration as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let frozen: u32 = unsafe { ::core::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let use_memdelay: u32 = unsafe { ::core::mem::transmute(use_memdelay) };
            use_memdelay as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let in_eventfd: u32 = unsafe { ::core::mem::transmute(in_eventfd) };
            in_eventfd as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let pasid_activated: u32 = unsafe { ::core::mem::transmute(pasid_activated) };
            pasid_activated as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let reported_split_lock: u32 = unsafe { ::core::mem::transmute(reported_split_lock) };
            reported_split_lock as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let in_thrashing: u32 = unsafe { ::core::mem::transmute(in_thrashing) };
            in_thrashing as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let in_nf_duplicate: u32 = unsafe { ::core::mem::transmute(in_nf_duplicate) };
            in_nf_duplicate as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn mce_ripv(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mce_ripv(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mce_ripv_raw(this: *const Self) -> __u64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_mce_ripv_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mce_whole_page(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mce_whole_page(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mce_whole_page_raw(this: *const Self) -> __u64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                1usize,
                1u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_mce_whole_page_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn __mce_reserved(&self) -> __u64 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set___mce_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn __mce_reserved_raw(this: *const Self) -> __u64 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                2usize,
                62u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set___mce_reserved_raw(this: *mut Self, val: __u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                2usize,
                62u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        mce_ripv: __u64,
        mce_whole_page: __u64,
        __mce_reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mce_ripv: u64 = unsafe { ::core::mem::transmute(mce_ripv) };
            mce_ripv as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mce_whole_page: u64 = unsafe { ::core::mem::transmute(mce_whole_page) };
            mce_whole_page as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let __mce_reserved: u64 = unsafe { ::core::mem::transmute(__mce_reserved) };
            __mce_reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_bl_head {
    pub first: *mut hlist_bl_node,
}
impl Default for hlist_bl_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_bl_node {
    pub next: *mut hlist_bl_node,
    pub pprev: *mut *mut hlist_bl_node,
}
impl Default for hlist_bl_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref {
    pub __bindgen_anon_1: lockref__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lockref__bindgen_ty_1 {
    pub lock_count: __u64,
    pub __bindgen_anon_1: lockref__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref__bindgen_ty_1__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub count: ffi::c_int,
}
impl Default for lockref__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for lockref__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for lockref {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qstr {
    pub __bindgen_anon_1: qstr__bindgen_ty_1,
    pub name: *const ffi::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qstr__bindgen_ty_1 {
    pub __bindgen_anon_1: qstr__bindgen_ty_1__bindgen_ty_1,
    pub hash_len: u64_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qstr__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u32_,
    pub len: u32_,
}
impl Default for qstr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for qstr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union shortname_store {
    pub string: [ffi::c_uchar; 40usize],
    pub words: [ffi::c_ulong; 5usize],
}
impl Default for shortname_store {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dentry {
    pub d_flags: ffi::c_uint,
    pub d_seq: seqcount_spinlock_t,
    pub d_hash: hlist_bl_node,
    pub d_parent: *mut dentry,
    pub __bindgen_anon_1: dentry__bindgen_ty_1,
    pub d_inode: *mut inode,
    pub d_shortname: shortname_store,
    pub d_op: *const dentry_operations,
    pub d_sb: *mut super_block,
    pub d_time: ffi::c_ulong,
    pub d_fsdata: *mut ffi::c_void,
    pub d_lockref: lockref,
    pub __bindgen_anon_2: dentry__bindgen_ty_2,
    pub d_sib: hlist_node,
    pub d_children: hlist_head,
    pub d_u: dentry__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_1 {
    pub __d_name: qstr,
    pub d_name: qstr,
}
impl Default for dentry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_2 {
    pub d_lru: list_head,
    pub d_wait: *mut wait_queue_head_t,
}
impl Default for dentry__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_3 {
    pub d_alias: hlist_node,
    pub d_in_lookup_hash: hlist_bl_node,
    pub d_rcu: callback_head,
}
impl Default for dentry__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for dentry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const d_real_type_D_REAL_DATA: d_real_type = 0;
pub const d_real_type_D_REAL_METADATA: d_real_type = 1;
pub type d_real_type = ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct dentry_operations {
    pub d_revalidate: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *const qstr,
            arg3: *mut dentry,
            arg4: ffi::c_uint,
        ) -> ffi::c_int,
    >,
    pub d_weak_revalidate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: ffi::c_uint) -> ffi::c_int,
    >,
    pub d_hash: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dentry, arg2: *mut qstr) -> ffi::c_int,
    >,
    pub d_compare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const dentry,
            arg2: ffi::c_uint,
            arg3: *const ffi::c_char,
            arg4: *const qstr,
        ) -> ffi::c_int,
    >,
    pub d_delete: ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry) -> ffi::c_int>,
    pub d_init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> ffi::c_int>,
    pub d_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_prune: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_iput: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut inode)>,
    pub d_dname: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut ffi::c_char,
            arg3: ffi::c_int,
        ) -> *mut ffi::c_char,
    >,
    pub d_automount: ::core::option::Option<unsafe extern "C" fn(arg1: *mut path) -> *mut vfsmount>,
    pub d_manage:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const path, arg2: bool_) -> ffi::c_int>,
    pub d_real: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, type_: d_real_type) -> *mut dentry,
    >,
    pub d_unalias_trylock:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry) -> bool_>,
    pub d_unalias_unlock: ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry)>,
}
impl Default for dentry_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct path {
    pub mnt: *mut vfsmount,
    pub dentry: *mut dentry,
}
impl Default for path {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type time64_t = __s64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec64 {
    pub tv_sec: time64_t,
    pub tv_nsec: ffi::c_long,
}
pub type old_time32_t = s32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct old_timespec32 {
    pub tv_sec: old_time32_t,
    pub tv_nsec: s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_namespace {
    pub uid_map: uid_gid_map,
    pub gid_map: uid_gid_map,
    pub projid_map: uid_gid_map,
    pub parent: *mut user_namespace,
    pub level: ffi::c_int,
    pub owner: kuid_t,
    pub group: kgid_t,
    pub ns: ns_common,
    pub flags: ffi::c_ulong,
    pub parent_could_setfcap: bool_,
    pub keyring_name_list: list_head,
    pub user_keyring_register: *mut key,
    pub keyring_sem: rw_semaphore,
    pub work: work_struct,
    pub set: ctl_table_set,
    pub sysctls: *mut ctl_table_header,
    pub ucounts: *mut ucounts,
    pub ucount_max: [ffi::c_long; 10usize],
    pub rlimit_max: [ffi::c_long; 4usize],
    pub binfmt_misc: *mut binfmt_misc,
}
impl Default for user_namespace {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kstat {
    pub result_mask: u32_,
    pub mode: umode_t,
    pub nlink: ffi::c_uint,
    pub blksize: u32,
    pub attributes: u64_,
    pub attributes_mask: u64_,
    pub ino: u64_,
    pub dev: dev_t,
    pub rdev: dev_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub size: loff_t,
    pub atime: timespec64,
    pub mtime: timespec64,
    pub ctime: timespec64,
    pub btime: timespec64,
    pub blocks: u64_,
    pub mnt_id: u64_,
    pub change_cookie: u64_,
    pub subvol: u64_,
    pub dio_mem_align: u32_,
    pub dio_offset_align: u32_,
    pub dio_read_offset_align: u32_,
    pub atomic_write_unit_min: u32_,
    pub atomic_write_unit_max: u32_,
    pub atomic_write_unit_max_opt: u32_,
    pub atomic_write_segments_max: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swait_queue_head {
    pub lock: raw_spinlock_t,
    pub task_list: list_head,
}
impl Default for swait_queue_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct completion {
    pub done: ffi::c_uint,
    pub wait: swait_queue_head,
}
impl Default for completion {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrink_control {
    pub gfp_mask: gfp_t,
    pub nid: ffi::c_int,
    pub nr_to_scan: ffi::c_ulong,
    pub nr_scanned: ffi::c_ulong,
    pub memcg: *mut mem_cgroup,
}
impl Default for shrink_control {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct shrinker {
    pub count_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> ffi::c_ulong,
    >,
    pub scan_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> ffi::c_ulong,
    >,
    pub batch: ffi::c_long,
    pub seeks: ffi::c_int,
    pub flags: ffi::c_uint,
    pub refcount: refcount_t,
    pub done: completion,
    pub rcu: callback_head,
    pub private_data: *mut ffi::c_void,
    pub list: list_head,
    pub nr_deferred: *mut atomic_long_t,
}
impl Default for shrinker {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_nulls_node {
    pub next: *mut hlist_nulls_node,
    pub pprev: *mut *mut hlist_nulls_node,
}
impl Default for hlist_nulls_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kref {
    pub refcount: refcount_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_tree {
    pub __bindgen_anon_1: maple_tree__bindgen_ty_1,
    pub ma_flags: ffi::c_uint,
    pub ma_root: *mut ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union maple_tree__bindgen_ty_1 {
    pub ma_lock: spinlock_t,
}
impl Default for maple_tree__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for maple_tree {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rw_semaphore {
    pub count: atomic_long_t,
    pub owner: atomic_long_t,
    pub osq: optimistic_spin_queue,
    pub wait_lock: raw_spinlock_t,
    pub wait_list: list_head,
}
impl Default for rw_semaphore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct workqueue_struct {
    _unused: [u8; 0],
}
pub type work_func_t = ::core::option::Option<unsafe extern "C" fn(work: *mut work_struct)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct work_struct {
    pub data: atomic_long_t,
    pub entry: list_head,
    pub func: work_func_t,
}
impl Default for work_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct delayed_work {
    pub work: work_struct,
    pub timer: timer_list,
    pub wq: *mut workqueue_struct,
    pub cpu: ffi::c_int,
}
impl Default for delayed_work {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_work {
    pub work: work_struct,
    pub rcu: callback_head,
    pub wq: *mut workqueue_struct,
}
impl Default for rcu_work {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_segcblist {
    pub head: *mut callback_head,
    pub tails: [*mut *mut callback_head; 4usize],
    pub gp_seq: [ffi::c_ulong; 4usize],
    pub len: ffi::c_long,
    pub seglen: [ffi::c_long; 4usize],
    pub flags: u8_,
}
impl Default for rcu_segcblist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct srcu_ctr {
    pub srcu_locks: atomic_long_t,
    pub srcu_unlocks: atomic_long_t,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct srcu_data {
    pub srcu_ctrs: [srcu_ctr; 2usize],
    pub srcu_reader_flavor: ffi::c_int,
    pub __bindgen_padding_0: [u32; 7usize],
    pub lock: spinlock_t,
    pub srcu_cblist: rcu_segcblist,
    pub srcu_gp_seq_needed: ffi::c_ulong,
    pub srcu_gp_seq_needed_exp: ffi::c_ulong,
    pub srcu_cblist_invoking: bool_,
    pub delay_work: timer_list,
    pub work: work_struct,
    pub srcu_barrier_head: callback_head,
    pub mynode: *mut srcu_node,
    pub grpmask: ffi::c_ulong,
    pub cpu: ffi::c_int,
    pub ssp: *mut srcu_struct,
}
impl Default for srcu_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_node {
    pub lock: spinlock_t,
    pub srcu_have_cbs: [ffi::c_ulong; 4usize],
    pub srcu_data_have_cbs: [ffi::c_ulong; 4usize],
    pub srcu_gp_seq_needed_exp: ffi::c_ulong,
    pub srcu_parent: *mut srcu_node,
    pub grplo: ffi::c_int,
    pub grphi: ffi::c_int,
}
impl Default for srcu_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_usage {
    pub node: *mut srcu_node,
    pub level: [*mut srcu_node; 3usize],
    pub srcu_size_state: ffi::c_int,
    pub srcu_cb_mutex: mutex,
    pub lock: spinlock_t,
    pub srcu_gp_mutex: mutex,
    pub srcu_gp_seq: ffi::c_ulong,
    pub srcu_gp_seq_needed: ffi::c_ulong,
    pub srcu_gp_seq_needed_exp: ffi::c_ulong,
    pub srcu_gp_start: ffi::c_ulong,
    pub srcu_last_gp_end: ffi::c_ulong,
    pub srcu_size_jiffies: ffi::c_ulong,
    pub srcu_n_lock_retries: ffi::c_ulong,
    pub srcu_n_exp_nodelay: ffi::c_ulong,
    pub sda_is_static: bool_,
    pub srcu_barrier_seq: ffi::c_ulong,
    pub srcu_barrier_mutex: mutex,
    pub srcu_barrier_completion: completion,
    pub srcu_barrier_cpu_cnt: atomic_t,
    pub reschedule_jiffies: ffi::c_ulong,
    pub reschedule_count: ffi::c_ulong,
    pub work: delayed_work,
    pub srcu_ssp: *mut srcu_struct,
}
impl Default for srcu_usage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct srcu_struct {
    pub srcu_ctrp: *mut srcu_ctr,
    pub sda: *mut srcu_data,
    pub dep_map: lockdep_map,
    pub srcu_sup: *mut srcu_usage,
}
impl Default for srcu_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_xol_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_uprobe {
    pub __bindgen_anon_1: arch_uprobe__bindgen_ty_1,
    pub ops: *const uprobe_xol_ops,
    pub __bindgen_anon_2: arch_uprobe__bindgen_ty_2,
    pub flags: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union arch_uprobe__bindgen_ty_1 {
    pub insn: [u8_; 16usize],
    pub ixol: [u8_; 16usize],
}
impl Default for arch_uprobe__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union arch_uprobe__bindgen_ty_2 {
    pub branch: arch_uprobe__bindgen_ty_2__bindgen_ty_1,
    pub defparam: arch_uprobe__bindgen_ty_2__bindgen_ty_2,
    pub push: arch_uprobe__bindgen_ty_2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct arch_uprobe__bindgen_ty_2__bindgen_ty_1 {
    pub offs: s32,
    pub ilen: u8_,
    pub opc1: u8_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct arch_uprobe__bindgen_ty_2__bindgen_ty_2 {
    pub fixups: u8_,
    pub ilen: u8_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct arch_uprobe__bindgen_ty_2__bindgen_ty_3 {
    pub reg_offset: u8_,
    pub ilen: u8_,
}
impl Default for arch_uprobe__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for arch_uprobe {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct arch_uprobe_task {
    pub saved_scratch_register: ffi::c_ulong,
    pub saved_trap_nr: ffi::c_uint,
    pub saved_tf: ffi::c_uint,
}
pub const uprobe_task_state_UTASK_RUNNING: uprobe_task_state = 0;
pub const uprobe_task_state_UTASK_SSTEP: uprobe_task_state = 1;
pub const uprobe_task_state_UTASK_SSTEP_ACK: uprobe_task_state = 2;
pub const uprobe_task_state_UTASK_SSTEP_TRAPPED: uprobe_task_state = 3;
pub type uprobe_task_state = ffi::c_uint;
pub const hprobe_state_HPROBE_LEASED: hprobe_state = 0;
pub const hprobe_state_HPROBE_STABLE: hprobe_state = 1;
pub const hprobe_state_HPROBE_GONE: hprobe_state = 2;
pub const hprobe_state_HPROBE_CONSUMED: hprobe_state = 3;
pub type hprobe_state = ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hprobe {
    pub state: hprobe_state,
    pub srcu_idx: ffi::c_int,
    pub uprobe: *mut uprobe,
}
impl Default for hprobe {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe_task {
    pub state: uprobe_task_state,
    pub depth: ffi::c_uint,
    pub return_instances: *mut return_instance,
    pub ri_pool: *mut return_instance,
    pub ri_timer: timer_list,
    pub ri_seqcount: seqcount_t,
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1,
    pub active_uprobe: *mut uprobe,
    pub xol_vaddr: ffi::c_ulong,
    pub signal_denied: bool_,
    pub auprobe: *mut arch_uprobe,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uprobe_task__bindgen_ty_1 {
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: uprobe_task__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_1 {
    pub autask: arch_uprobe_task,
    pub vaddr: ffi::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    pub dup_xol_work: callback_head,
    pub dup_xol_addr: ffi::c_ulong,
}
impl Default for uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for uprobe_task__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for uprobe_task {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct return_consumer {
    pub cookie: __u64,
    pub id: __u64,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct return_instance {
    pub hprobe: hprobe,
    pub func: ffi::c_ulong,
    pub stack: ffi::c_ulong,
    pub orig_ret_vaddr: ffi::c_ulong,
    pub chained: bool_,
    pub cons_cnt: ffi::c_int,
    pub next: *mut return_instance,
    pub rcu: callback_head,
    pub consumer: return_consumer,
    pub extra_consumers: *mut return_consumer,
}
impl Default for return_instance {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xol_area {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobes_state {
    pub xol_area: *mut xol_area,
    pub head_tramps: hlist_head,
}
impl Default for uprobes_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_counter {
    pub lock: raw_spinlock_t,
    pub count: s64,
    pub list: list_head,
    pub counters: *mut s32,
}
impl Default for percpu_counter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_context_t {
    pub ctx_id: u64_,
    pub tlb_gen: atomic64_t,
    pub next_trim_cpumask: ffi::c_ulong,
    pub ldt_usr_sem: rw_semaphore,
    pub ldt: *mut ldt_struct,
    pub flags: ffi::c_ulong,
    pub lock: mutex,
    pub vdso: *mut ffi::c_void,
    pub vdso_image: *const vdso_image,
    pub perf_rdpmc_allowed: atomic_t,
    pub pkey_allocation_map: u16_,
    pub execute_only_pkey: s16,
    pub global_asid: u16_,
    pub asid_transition: bool_,
}
impl Default for mm_context_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct futex_private_hash {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct memdesc_flags_t {
    pub f: ffi::c_ulong,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct page {
    pub flags: memdesc_flags_t,
    pub __bindgen_anon_1: page__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_2,
    pub _refcount: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: page__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: page__bindgen_ty_1__bindgen_ty_4,
    pub callback_head: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub mapping: *mut address_space,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub private: ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub lru: list_head,
    pub buddy_list: list_head,
    pub pcp_list: list_head,
    pub pcp_llist: llist_node,
}
impl Default for page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub __folio_index: ffi::c_ulong,
    pub share: ffi::c_ulong,
}
impl Default for page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for page__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_2 {
    pub pp_magic: ffi::c_ulong,
    pub pp: *mut page_pool,
    pub _pp_mapping_pad: ffi::c_ulong,
    pub dma_addr: ffi::c_ulong,
    pub pp_ref_count: atomic_long_t,
}
impl Default for page__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_3 {
    pub compound_head: ffi::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_4 {
    pub _unused_pgmap_compound_head: *mut ffi::c_void,
    pub zone_device_data: *mut ffi::c_void,
}
impl Default for page__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for page__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_2 {
    pub page_type: ffi::c_uint,
    pub _mapcount: atomic_t,
}
impl Default for page__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for page {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct swp_entry_t {
    pub val: ffi::c_ulong,
}
pub type mm_id_mapcount_t = ffi::c_int;
pub type mm_id_t = ffi::c_uint;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct folio {
    pub __bindgen_anon_1: folio__bindgen_ty_1,
    pub __bindgen_anon_2: folio__bindgen_ty_2,
    pub __bindgen_anon_3: folio__bindgen_ty_3,
    pub __bindgen_anon_4: folio__bindgen_ty_4,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1 {
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1,
    pub page: page,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_1__bindgen_ty_1 {
    pub flags: memdesc_flags_t,
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub mapping: *mut address_space,
    pub __bindgen_anon_2: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3,
    pub _mapcount: atomic_t,
    pub _refcount: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub lru: list_head,
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub pgmap: *mut dev_pagemap,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __filler: *mut ffi::c_void,
    pub mlock_count: ffi::c_uint,
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub index: ffi::c_ulong,
    pub share: ffi::c_ulong,
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    pub private: *mut ffi::c_void,
    pub swap: swp_entry_t,
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_2 {
    pub __bindgen_anon_1: folio__bindgen_ty_2__bindgen_ty_1,
    pub __page_1: page,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_2__bindgen_ty_1 {
    pub _flags_1: ffi::c_ulong,
    pub _head_1: ffi::c_ulong,
    pub __bindgen_anon_1: folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub _mapcount_1: atomic_t,
    pub _refcount_1: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub _usable_1: [ffi::c_ulong; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _large_mapcount: atomic_t,
    pub _nr_pages_mapped: atomic_t,
    pub _entire_mapcount: atomic_t,
    pub _pincount: atomic_t,
    pub _mm_id_mapcount: [mm_id_mapcount_t; 2usize],
    pub __bindgen_anon_1:
        folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _mm_id: [mm_id_t; 2usize],
    pub _mm_ids: ffi::c_ulong,
}
impl Default for folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_3 {
    pub __bindgen_anon_1: folio__bindgen_ty_3__bindgen_ty_1,
    pub __page_2: page,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct folio__bindgen_ty_3__bindgen_ty_1 {
    pub _flags_2: ffi::c_ulong,
    pub _head_2: ffi::c_ulong,
    pub _deferred_list: list_head,
}
impl Default for folio__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_4 {
    pub __bindgen_anon_1: folio__bindgen_ty_4__bindgen_ty_1,
    pub __page_3: page,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct folio__bindgen_ty_4__bindgen_ty_1 {
    pub _flags_3: ffi::c_ulong,
    pub _head_3: ffi::c_ulong,
    pub _hugetlb_subpool: *mut ffi::c_void,
    pub _hugetlb_cgroup: *mut ffi::c_void,
    pub _hugetlb_cgroup_rsvd: *mut ffi::c_void,
    pub _hugetlb_hwpoison: *mut ffi::c_void,
}
impl Default for folio__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for folio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vm_flags_t = ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct freeptr_t {
    pub v: ffi::c_ulong,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vm_userfaultfd_ctx {}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pfnmap_track_ctx {
    pub kref: kref,
    pub pfn: ffi::c_ulong,
    pub size: ffi::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_desc {
    pub mm: *const mm_struct,
    pub file: *mut file,
    pub start: ffi::c_ulong,
    pub end: ffi::c_ulong,
    pub pgoff: ffi::c_ulong,
    pub vm_file: *mut file,
    pub vm_flags: vm_flags_t,
    pub page_prot: pgprot_t,
    pub vm_ops: *const vm_operations_struct,
    pub private_data: *mut ffi::c_void,
}
impl Default for vm_area_desc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct vm_area_struct {
    pub __bindgen_anon_1: vm_area_struct__bindgen_ty_1,
    pub vm_mm: *mut mm_struct,
    pub vm_page_prot: pgprot_t,
    pub __bindgen_anon_2: vm_area_struct__bindgen_ty_2,
    pub vm_lock_seq: ffi::c_uint,
    pub anon_vma_chain: list_head,
    pub anon_vma: *mut anon_vma,
    pub vm_ops: *const vm_operations_struct,
    pub vm_pgoff: ffi::c_ulong,
    pub vm_file: *mut file,
    pub vm_private_data: *mut ffi::c_void,
    pub swap_readahead_info: atomic_long_t,
    pub vm_policy: *mut mempolicy,
    pub __bindgen_padding_0: [u32; 2usize],
    pub vm_refcnt: refcount_t,
    pub shared: vm_area_struct__bindgen_ty_3,
    pub vm_userfaultfd_ctx: vm_userfaultfd_ctx,
    pub pfnmap_track_ctx: *mut pfnmap_track_ctx,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_area_struct__bindgen_ty_1 {
    pub __bindgen_anon_1: vm_area_struct__bindgen_ty_1__bindgen_ty_1,
    pub vm_freeptr: freeptr_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vm_area_struct__bindgen_ty_1__bindgen_ty_1 {
    pub vm_start: ffi::c_ulong,
    pub vm_end: ffi::c_ulong,
}
impl Default for vm_area_struct__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_area_struct__bindgen_ty_2 {
    pub vm_flags: vm_flags_t,
    pub __vm_flags: vm_flags_t,
}
impl Default for vm_area_struct__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_struct__bindgen_ty_3 {
    pub rb: rb_node,
    pub rb_subtree_last: ffi::c_ulong,
}
impl Default for vm_area_struct__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vm_area_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mm_cid {
    pub time: u64_,
    pub cid: ffi::c_int,
    pub recent_cid: ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mm_flags_t {
    pub __mm_flags: [ffi::c_ulong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kioctx_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_mm_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
pub struct mm_struct {
    pub __bindgen_anon_1: mm_struct__bindgen_ty_1,
    pub cpu_bitmap: __IncompleteArrayField<ffi::c_ulong>,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct mm_struct__bindgen_ty_1 {
    pub __bindgen_anon_1: mm_struct__bindgen_ty_1__bindgen_ty_1,
    pub mm_mt: maple_tree,
    pub mmap_base: ffi::c_ulong,
    pub mmap_legacy_base: ffi::c_ulong,
    pub mmap_compat_base: ffi::c_ulong,
    pub mmap_compat_legacy_base: ffi::c_ulong,
    pub task_size: ffi::c_ulong,
    pub pgd: *mut pgd_t,
    pub membarrier_state: atomic_t,
    pub mm_users: atomic_t,
    pub pcpu_cid: *mut mm_cid,
    pub mm_cid_next_scan: ffi::c_ulong,
    pub nr_cpus_allowed: ffi::c_uint,
    pub max_nr_cid: atomic_t,
    pub cpus_allowed_lock: raw_spinlock_t,
    pub pgtables_bytes: atomic_long_t,
    pub map_count: ffi::c_int,
    pub page_table_lock: spinlock_t,
    pub mmap_lock: rw_semaphore,
    pub mmlist: list_head,
    pub vma_writer_wait: rcuwait,
    pub mm_lock_seq: seqcount_t,
    pub futex_hash_lock: mutex,
    pub futex_phash: *mut futex_private_hash,
    pub futex_phash_new: *mut futex_private_hash,
    pub futex_batches: ffi::c_ulong,
    pub futex_rcu: callback_head,
    pub futex_atomic: atomic_long_t,
    pub futex_ref: *mut ffi::c_uint,
    pub hiwater_rss: ffi::c_ulong,
    pub hiwater_vm: ffi::c_ulong,
    pub total_vm: ffi::c_ulong,
    pub locked_vm: ffi::c_ulong,
    pub pinned_vm: atomic64_t,
    pub data_vm: ffi::c_ulong,
    pub exec_vm: ffi::c_ulong,
    pub stack_vm: ffi::c_ulong,
    pub def_flags: vm_flags_t,
    pub write_protect_seq: seqcount_t,
    pub arg_lock: spinlock_t,
    pub start_code: ffi::c_ulong,
    pub end_code: ffi::c_ulong,
    pub start_data: ffi::c_ulong,
    pub end_data: ffi::c_ulong,
    pub start_brk: ffi::c_ulong,
    pub brk: ffi::c_ulong,
    pub start_stack: ffi::c_ulong,
    pub arg_start: ffi::c_ulong,
    pub arg_end: ffi::c_ulong,
    pub env_start: ffi::c_ulong,
    pub env_end: ffi::c_ulong,
    pub saved_auxv: [ffi::c_ulong; 52usize],
    pub rss_stat: [percpu_counter; 4usize],
    pub binfmt: *mut linux_binfmt,
    pub context: mm_context_t,
    pub flags: mm_flags_t,
    pub ioctx_lock: spinlock_t,
    pub ioctx_table: *mut kioctx_table,
    pub user_ns: *mut user_namespace,
    pub exe_file: *mut file,
    pub notifier_subscriptions: *mut mmu_notifier_subscriptions,
    pub tlb_flush_pending: atomic_t,
    pub tlb_flush_batched: atomic_t,
    pub uprobes_state: uprobes_state,
    pub hugetlb_usage: atomic_long_t,
    pub async_put_work: work_struct,
    pub iommu_mm: *mut iommu_mm_data,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct mm_struct__bindgen_ty_1__bindgen_ty_1 {
    pub mm_count: atomic_t,
}
impl Default for mm_struct__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mm_struct__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for mm_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vm_fault_t = ffi::c_uint;
pub const fault_flag_FAULT_FLAG_WRITE: fault_flag = 1;
pub const fault_flag_FAULT_FLAG_MKWRITE: fault_flag = 2;
pub const fault_flag_FAULT_FLAG_ALLOW_RETRY: fault_flag = 4;
pub const fault_flag_FAULT_FLAG_RETRY_NOWAIT: fault_flag = 8;
pub const fault_flag_FAULT_FLAG_KILLABLE: fault_flag = 16;
pub const fault_flag_FAULT_FLAG_TRIED: fault_flag = 32;
pub const fault_flag_FAULT_FLAG_USER: fault_flag = 64;
pub const fault_flag_FAULT_FLAG_REMOTE: fault_flag = 128;
pub const fault_flag_FAULT_FLAG_INSTRUCTION: fault_flag = 256;
pub const fault_flag_FAULT_FLAG_INTERRUPTIBLE: fault_flag = 512;
pub const fault_flag_FAULT_FLAG_UNSHARE: fault_flag = 1024;
pub const fault_flag_FAULT_FLAG_ORIG_PTE_VALID: fault_flag = 2048;
pub const fault_flag_FAULT_FLAG_VMA_LOCK: fault_flag = 4096;
pub type fault_flag = ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_domain {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn folio_alloc_noprof(gfp: gfp_t, order: ffi::c_uint) -> *mut folio;
}
unsafe extern "C" {
    pub fn folio_alloc_mpol_noprof(
        gfp: gfp_t,
        order: ffi::c_uint,
        mpol: *mut mempolicy,
        ilx: ffi::c_ulong,
        nid: ffi::c_int,
    ) -> *mut folio;
}
unsafe extern "C" {
    pub fn generic_get_unmapped_area(
        filp: *mut file,
        addr: ffi::c_ulong,
        len: ffi::c_ulong,
        pgoff: ffi::c_ulong,
        flags: ffi::c_ulong,
        vm_flags: vm_flags_t,
    ) -> ffi::c_ulong;
}
unsafe extern "C" {
    pub fn generic_get_unmapped_area_topdown(
        filp: *mut file,
        addr: ffi::c_ulong,
        len: ffi::c_ulong,
        pgoff: ffi::c_ulong,
        flags: ffi::c_ulong,
        vm_flags: vm_flags_t,
    ) -> ffi::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xarray {
    pub xa_lock: spinlock_t,
    pub xa_flags: gfp_t,
    pub xa_head: *mut ffi::c_void,
}
impl Default for xarray {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_lru_one {
    pub list: list_head,
    pub nr_items: ffi::c_long,
    pub lock: spinlock_t,
}
impl Default for list_lru_one {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct list_lru_node {
    pub lru: list_lru_one,
    pub nr_items: atomic_long_t,
}
impl Default for list_lru_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_lru {
    pub node: *mut list_lru_node,
}
impl Default for list_lru {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pidfs_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct upid {
    pub nr: ffi::c_int,
    pub ns: *mut pid_namespace,
}
impl Default for upid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct pid {
    pub count: refcount_t,
    pub level: ffi::c_uint,
    pub lock: spinlock_t,
    pub __bindgen_anon_1: pid__bindgen_ty_1,
    pub tasks: [hlist_head; 4usize],
    pub inodes: hlist_head,
    pub wait_pidfd: wait_queue_head_t,
    pub rcu: callback_head,
    pub numbers: __IncompleteArrayField<upid>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pid__bindgen_ty_1 {
    pub ino: u64_,
    pub pidfs_node: rb_node,
    pub stashed: *mut dentry,
    pub attr: *mut pidfs_attr,
}
impl Default for pid__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernel_cap_t {
    pub val: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mnt_idmap {
    _unused: [u8; 0],
}
pub const migrate_mode_MIGRATE_ASYNC: migrate_mode = 0;
pub const migrate_mode_MIGRATE_SYNC_LIGHT: migrate_mode = 1;
pub const migrate_mode_MIGRATE_SYNC: migrate_mode = 2;
pub type migrate_mode = ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct exception_table_entry {
    pub insn: ffi::c_int,
    pub fixup: ffi::c_int,
    pub data: ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmu_notifier_subscriptions {
    _unused: [u8; 0],
}
pub type proc_handler = ::core::option::Option<
    unsafe extern "C" fn(
        ctl: *const ctl_table,
        write: ffi::c_int,
        buffer: *mut ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_poll {
    pub event: atomic_t,
    pub wait: wait_queue_head_t,
}
impl Default for ctl_table_poll {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_table {
    pub procname: *const ffi::c_char,
    pub data: *mut ffi::c_void,
    pub maxlen: ffi::c_int,
    pub mode: umode_t,
    pub proc_handler: proc_handler,
    pub poll: *mut ctl_table_poll,
    pub extra1: *mut ffi::c_void,
    pub extra2: *mut ffi::c_void,
}
impl Default for ctl_table {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_node {
    pub node: rb_node,
    pub header: *mut ctl_table_header,
}
impl Default for ctl_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_header {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1,
    pub unregistering: *mut completion,
    pub ctl_table_arg: *const ctl_table,
    pub root: *mut ctl_table_root,
    pub set: *mut ctl_table_set,
    pub parent: *mut ctl_dir,
    pub node: *mut ctl_node,
    pub inodes: hlist_head,
    pub type_: ctl_table_header__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ctl_table_header__bindgen_ty_1 {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1__bindgen_ty_1,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    pub ctl_table: *const ctl_table,
    pub ctl_table_size: ffi::c_int,
    pub used: ffi::c_int,
    pub count: ffi::c_int,
    pub nreg: ffi::c_int,
}
impl Default for ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ctl_table_header__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ctl_table_header_SYSCTL_TABLE_TYPE_DEFAULT: ctl_table_header__bindgen_ty_2 = 0;
pub const ctl_table_header_SYSCTL_TABLE_TYPE_PERMANENTLY_EMPTY: ctl_table_header__bindgen_ty_2 = 1;
pub type ctl_table_header__bindgen_ty_2 = ffi::c_uint;
impl Default for ctl_table_header {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_dir {
    pub header: ctl_table_header,
    pub root: rb_root,
}
impl Default for ctl_dir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_set {
    pub is_seen:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ctl_table_set) -> ffi::c_int>,
    pub dir: ctl_dir,
}
impl Default for ctl_table_set {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_root {
    pub default_set: ctl_table_set,
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(root: *mut ctl_table_root) -> *mut ctl_table_set,
    >,
    pub set_ownership: ::core::option::Option<
        unsafe extern "C" fn(head: *mut ctl_table_header, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
    pub permissions: ::core::option::Option<
        unsafe extern "C" fn(head: *mut ctl_table_header, table: *const ctl_table) -> ffi::c_int,
    >,
}
impl Default for ctl_table_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct assoc_array {
    pub root: *mut assoc_array_ptr,
    pub nr_leaves_on_tree: ffi::c_ulong,
}
impl Default for assoc_array {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type key_serial_t = i32;
pub type key_perm_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_tag {
    pub rcu: callback_head,
    pub usage: refcount_t,
    pub removed: bool_,
}
impl Default for key_tag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct keyring_index_key {
    pub hash: ffi::c_ulong,
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *const ffi::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union keyring_index_key__bindgen_ty_1 {
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1__bindgen_ty_1,
    pub x: ffi::c_ulong,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct keyring_index_key__bindgen_ty_1__bindgen_ty_1 {
    pub desc_len: u16_,
    pub desc: [ffi::c_char; 6usize],
}
impl Default for keyring_index_key__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for keyring_index_key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key_payload {
    pub rcu_data0: *mut ffi::c_void,
    pub data: [*mut ffi::c_void; 4usize],
}
impl Default for key_payload {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type key_restrict_link_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        dest_keyring: *mut key,
        type_: *const key_type,
        payload: *const key_payload,
        restriction_key: *mut key,
    ) -> ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_restriction {
    pub check: key_restrict_link_func_t,
    pub key: *mut key,
    pub keytype: *mut key_type,
}
impl Default for key_restriction {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key {
    pub usage: refcount_t,
    pub serial: key_serial_t,
    pub __bindgen_anon_1: key__bindgen_ty_1,
    pub sem: rw_semaphore,
    pub user: *mut key_user,
    pub security: *mut ffi::c_void,
    pub __bindgen_anon_2: key__bindgen_ty_2,
    pub last_used_at: time64_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub perm: key_perm_t,
    pub quotalen: ffi::c_ushort,
    pub datalen: ffi::c_ushort,
    pub state: ffi::c_short,
    pub flags: ffi::c_ulong,
    pub __bindgen_anon_3: key__bindgen_ty_3,
    pub __bindgen_anon_4: key__bindgen_ty_4,
    pub restrict_link: *mut key_restriction,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_1 {
    pub graveyard_link: list_head,
    pub serial_node: rb_node,
}
impl Default for key__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_2 {
    pub expiry: time64_t,
    pub revoked_at: time64_t,
}
impl Default for key__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_3 {
    pub index_key: keyring_index_key,
    pub __bindgen_anon_1: key__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key__bindgen_ty_3__bindgen_ty_1 {
    pub hash: ffi::c_ulong,
    pub len_desc: ffi::c_ulong,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *mut ffi::c_char,
}
impl Default for key__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for key__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_4 {
    pub payload: key_payload,
    pub __bindgen_anon_1: key__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key__bindgen_ty_4__bindgen_ty_1 {
    pub name_link: list_head,
    pub keys: assoc_array,
}
impl Default for key__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for key__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for key {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_struct {
    pub __count: refcount_t,
    pub epoll_watches: percpu_counter,
    pub unix_inflight: ffi::c_ulong,
    pub pipe_bufs: atomic_long_t,
    pub uidhash_node: hlist_node,
    pub uid: kuid_t,
    pub locked_vm: atomic_long_t,
    pub ratelimit: ratelimit_state,
}
impl Default for user_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct group_info {
    pub usage: refcount_t,
    pub ngroups: ffi::c_int,
    pub gid: __IncompleteArrayField<kgid_t>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cred {
    pub usage: atomic_long_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub suid: kuid_t,
    pub sgid: kgid_t,
    pub euid: kuid_t,
    pub egid: kgid_t,
    pub fsuid: kuid_t,
    pub fsgid: kgid_t,
    pub securebits: ffi::c_uint,
    pub cap_inheritable: kernel_cap_t,
    pub cap_permitted: kernel_cap_t,
    pub cap_effective: kernel_cap_t,
    pub cap_bset: kernel_cap_t,
    pub cap_ambient: kernel_cap_t,
    pub jit_keyring: ffi::c_uchar,
    pub session_keyring: *mut key,
    pub process_keyring: *mut key,
    pub thread_keyring: *mut key,
    pub request_key_auth: *mut key,
    pub security: *mut ffi::c_void,
    pub user: *mut user_struct,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub group_info: *mut group_info,
    pub __bindgen_anon_1: cred__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cred__bindgen_ty_1 {
    pub non_rcu: ffi::c_int,
    pub rcu: callback_head,
}
impl Default for cred__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cred {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct hrtimer_clock_base {
    pub cpu_base: *mut hrtimer_cpu_base,
    pub index: ffi::c_uint,
    pub clockid: clockid_t,
    pub seq: seqcount_raw_spinlock_t,
    pub running: *mut hrtimer,
    pub active: timerqueue_head,
    pub offset: ktime_t,
}
impl Default for hrtimer_clock_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_cpu_base {
    pub lock: raw_spinlock_t,
    pub cpu: ffi::c_uint,
    pub active_bases: ffi::c_uint,
    pub clock_was_set_seq: ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub nr_events: ffi::c_uint,
    pub nr_retries: ffi::c_ushort,
    pub nr_hangs: ffi::c_ushort,
    pub max_hang_time: ffi::c_uint,
    pub expires_next: ktime_t,
    pub next_timer: *mut hrtimer,
    pub softirq_expires_next: ktime_t,
    pub softirq_next_timer: *mut hrtimer,
    pub clock_base: [hrtimer_clock_base; 8usize],
    pub csd: call_single_data_t,
}
impl Default for hrtimer_cpu_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl hrtimer_cpu_base {
    #[inline]
    pub fn hres_active(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hres_active(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hres_active_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hres_active_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_hrtirq(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_hrtirq(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_hrtirq_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_hrtirq_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hang_detected(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hang_detected(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hang_detected_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hang_detected_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn softirq_activated(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_softirq_activated(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn softirq_activated_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_softirq_activated_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn online(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_online(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn online_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_online_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hres_active: ffi::c_uint,
        in_hrtirq: ffi::c_uint,
        hang_detected: ffi::c_uint,
        softirq_activated: ffi::c_uint,
        online: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hres_active: u32 = unsafe { ::core::mem::transmute(hres_active) };
            hres_active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_hrtirq: u32 = unsafe { ::core::mem::transmute(in_hrtirq) };
            in_hrtirq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hang_detected: u32 = unsafe { ::core::mem::transmute(hang_detected) };
            hang_detected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let softirq_activated: u32 = unsafe { ::core::mem::transmute(softirq_activated) };
            softirq_activated as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let online: u32 = unsafe { ::core::mem::transmute(online) };
            online as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sighand_struct {
    pub siglock: spinlock_t,
    pub count: refcount_t,
    pub signalfd_wqh: wait_queue_head_t,
    pub action: [k_sigaction; 64usize],
}
impl Default for sighand_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pacct_struct {
    pub ac_flag: ffi::c_int,
    pub ac_exitcode: ffi::c_long,
    pub ac_mem: ffi::c_ulong,
    pub ac_utime: u64_,
    pub ac_stime: u64_,
    pub ac_minflt: ffi::c_ulong,
    pub ac_majflt: ffi::c_ulong,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cpu_itimer {
    pub expires: u64_,
    pub incr: u64_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct task_cputime_atomic {
    pub utime: atomic64_t,
    pub stime: atomic64_t,
    pub sum_exec_runtime: atomic64_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct thread_group_cputimer {
    pub cputime_atomic: task_cputime_atomic,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct core_thread {
    pub task: *mut task_struct,
    pub next: *mut core_thread,
}
impl Default for core_thread {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct core_state {
    pub nr_threads: atomic_t,
    pub dumper: core_thread,
    pub startup: completion,
}
impl Default for core_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct signal_struct {
    pub sigcnt: refcount_t,
    pub live: atomic_t,
    pub nr_threads: ffi::c_int,
    pub quick_threads: ffi::c_int,
    pub thread_head: list_head,
    pub wait_chldexit: wait_queue_head_t,
    pub curr_target: *mut task_struct,
    pub shared_pending: sigpending,
    pub multiprocess: hlist_head,
    pub group_exit_code: ffi::c_int,
    pub notify_count: ffi::c_int,
    pub group_exec_task: *mut task_struct,
    pub group_stop_count: ffi::c_int,
    pub flags: ffi::c_uint,
    pub core_state: *mut core_state,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub next_posix_timer_id: atomic_t,
    pub posix_timers: hlist_head,
    pub ignored_posix_timers: hlist_head,
    pub real_timer: hrtimer,
    pub it_real_incr: ktime_t,
    pub it: [cpu_itimer; 2usize],
    pub cputimer: thread_group_cputimer,
    pub posix_cputimers: posix_cputimers,
    pub pids: [*mut pid; 4usize],
    pub tty_old_pgrp: *mut pid,
    pub leader: ffi::c_int,
    pub tty: *mut tty_struct,
    pub stats_lock: seqlock_t,
    pub utime: u64_,
    pub stime: u64_,
    pub cutime: u64_,
    pub cstime: u64_,
    pub gtime: u64_,
    pub cgtime: u64_,
    pub prev_cputime: prev_cputime,
    pub nvcsw: ffi::c_ulong,
    pub nivcsw: ffi::c_ulong,
    pub cnvcsw: ffi::c_ulong,
    pub cnivcsw: ffi::c_ulong,
    pub min_flt: ffi::c_ulong,
    pub maj_flt: ffi::c_ulong,
    pub cmin_flt: ffi::c_ulong,
    pub cmaj_flt: ffi::c_ulong,
    pub inblock: ffi::c_ulong,
    pub oublock: ffi::c_ulong,
    pub cinblock: ffi::c_ulong,
    pub coublock: ffi::c_ulong,
    pub maxrss: ffi::c_ulong,
    pub cmaxrss: ffi::c_ulong,
    pub ioac: task_io_accounting,
    pub sum_sched_runtime: ffi::c_ulonglong,
    pub rlim: [rlimit; 16usize],
    pub pacct: pacct_struct,
    pub stats: *mut taskstats,
    pub audit_tty: ffi::c_uint,
    pub tty_audit_buf: *mut tty_audit_buf,
    pub cgroup_threadgroup_rwsem: rw_semaphore,
    pub oom_flag_origin: bool_,
    pub oom_score_adj: ffi::c_short,
    pub oom_score_adj_min: ffi::c_short,
    pub oom_mm: *mut mm_struct,
    pub cred_guard_mutex: mutex,
    pub exec_update_lock: rw_semaphore,
}
impl Default for signal_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl signal_struct {
    #[inline]
    pub fn is_child_subreaper(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_child_subreaper(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_child_subreaper_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_child_subreaper_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn has_child_subreaper(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_child_subreaper(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn has_child_subreaper_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_has_child_subreaper_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn timer_create_restore_ids(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_create_restore_ids(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn timer_create_restore_ids_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_timer_create_restore_ids_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_child_subreaper: ffi::c_uint,
        has_child_subreaper: ffi::c_uint,
        timer_create_restore_ids: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_child_subreaper: u32 = unsafe { ::core::mem::transmute(is_child_subreaper) };
            is_child_subreaper as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_child_subreaper: u32 = unsafe { ::core::mem::transmute(has_child_subreaper) };
            has_child_subreaper as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let timer_create_restore_ids: u32 =
                unsafe { ::core::mem::transmute(timer_create_restore_ids) };
            timer_create_restore_ids as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_sync {
    pub gp_state: ffi::c_int,
    pub gp_count: ffi::c_int,
    pub gp_wait: wait_queue_head_t,
    pub cb_head: callback_head,
}
impl Default for rcu_sync {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_rw_semaphore {
    pub rss: rcu_sync,
    pub read_count: *mut ffi::c_uint,
    pub writer: rcuwait,
    pub waiters: wait_queue_head_t,
    pub block: atomic_t,
}
impl Default for percpu_rw_semaphore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct delayed_call {
    pub fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ffi::c_void)>,
    pub arg: *mut ffi::c_void,
}
impl Default for delayed_call {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uuid_t {
    pub b: [__u8; 16usize],
}
pub type errseq_t = u32_;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_context {
    pub refcount: atomic_long_t,
    pub active_ref: atomic_t,
    pub ioprio: ffi::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfsmount {
    pub mnt_root: *mut dentry,
    pub mnt_sb: *mut super_block,
    pub mnt_flags: ffi::c_int,
    pub mnt_idmap: *mut mnt_idmap,
}
impl Default for vfsmount {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfsuid_t {
    pub val: uid_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vfsgid_t {
    pub val: gid_t,
}
pub type percpu_ref_func_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut percpu_ref)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct percpu_ref_data {
    pub count: atomic_long_t,
    pub release: percpu_ref_func_t,
    pub confirm_switch: percpu_ref_func_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub rcu: callback_head,
    pub ref_: *mut percpu_ref,
}
impl Default for percpu_ref_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl percpu_ref_data {
    #[inline]
    pub fn force_atomic(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_atomic(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn force_atomic_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_force_atomic_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn allow_reinit(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_allow_reinit(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allow_reinit_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_allow_reinit_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_atomic: bool_,
        allow_reinit: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_atomic: u8 = unsafe { ::core::mem::transmute(force_atomic) };
            force_atomic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let allow_reinit: u8 = unsafe { ::core::mem::transmute(allow_reinit) };
            allow_reinit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct percpu_ref {
    pub percpu_count_ptr: ffi::c_ulong,
    pub data: *mut percpu_ref_data,
}
impl Default for percpu_ref {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_struct {
    _unused: [u8; 0],
}
pub const rw_hint_WRITE_LIFE_NOT_SET: rw_hint = 0;
pub const rw_hint_WRITE_LIFE_NONE: rw_hint = 1;
pub const rw_hint_WRITE_LIFE_SHORT: rw_hint = 2;
pub const rw_hint_WRITE_LIFE_MEDIUM: rw_hint = 3;
pub const rw_hint_WRITE_LIFE_LONG: rw_hint = 4;
pub const rw_hint_WRITE_LIFE_EXTREME: rw_hint = 5;
pub const rw_hint_WRITE_LIFE_HINT_NR: rw_hint = 6;
pub type rw_hint = ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct file_ref_t {
    pub refcnt: atomic64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_comp_batch {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct export_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fiemap_extent_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct poll_table_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kstatfs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swap_info_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsnotify_mark_connector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsnotify_sb_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_parameter_spec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_kattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iattr {
    pub ia_valid: ffi::c_uint,
    pub ia_mode: umode_t,
    pub __bindgen_anon_1: iattr__bindgen_ty_1,
    pub __bindgen_anon_2: iattr__bindgen_ty_2,
    pub ia_size: loff_t,
    pub ia_atime: timespec64,
    pub ia_mtime: timespec64,
    pub ia_ctime: timespec64,
    pub ia_file: *mut file,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iattr__bindgen_ty_1 {
    pub ia_uid: kuid_t,
    pub ia_vfsuid: vfsuid_t,
}
impl Default for iattr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iattr__bindgen_ty_2 {
    pub ia_gid: kgid_t,
    pub ia_vfsgid: vfsgid_t,
}
impl Default for iattr__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iattr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type projid_t = __kernel_uid32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kprojid_t {
    pub val: projid_t,
}
pub const quota_type_USRQUOTA: quota_type = 0;
pub const quota_type_GRPQUOTA: quota_type = 1;
pub const quota_type_PRJQUOTA: quota_type = 2;
pub type quota_type = ffi::c_uint;
pub type qsize_t = ffi::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kqid {
    pub __bindgen_anon_1: kqid__bindgen_ty_1,
    pub type_: quota_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kqid__bindgen_ty_1 {
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub projid: kprojid_t,
}
impl Default for kqid__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kqid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mem_dqblk {
    pub dqb_bhardlimit: qsize_t,
    pub dqb_bsoftlimit: qsize_t,
    pub dqb_curspace: qsize_t,
    pub dqb_rsvspace: qsize_t,
    pub dqb_ihardlimit: qsize_t,
    pub dqb_isoftlimit: qsize_t,
    pub dqb_curinodes: qsize_t,
    pub dqb_btime: time64_t,
    pub dqb_itime: time64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_dqinfo {
    pub dqi_format: *mut quota_format_type,
    pub dqi_fmt_id: ffi::c_int,
    pub dqi_dirty_list: list_head,
    pub dqi_flags: ffi::c_ulong,
    pub dqi_bgrace: ffi::c_uint,
    pub dqi_igrace: ffi::c_uint,
    pub dqi_max_spc_limit: qsize_t,
    pub dqi_max_ino_limit: qsize_t,
    pub dqi_priv: *mut ffi::c_void,
}
impl Default for mem_dqinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dquot {
    pub dq_hash: hlist_node,
    pub dq_inuse: list_head,
    pub dq_free: list_head,
    pub dq_dirty: list_head,
    pub dq_lock: mutex,
    pub dq_dqb_lock: spinlock_t,
    pub dq_count: atomic_t,
    pub dq_sb: *mut super_block,
    pub dq_id: kqid,
    pub dq_off: loff_t,
    pub dq_flags: ffi::c_ulong,
    pub dq_dqb: mem_dqblk,
}
impl Default for dquot {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct quota_format_ops {
    pub check_quota_file: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: ffi::c_int) -> ffi::c_int,
    >,
    pub read_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: ffi::c_int) -> ffi::c_int,
    >,
    pub write_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: ffi::c_int) -> ffi::c_int,
    >,
    pub free_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: ffi::c_int) -> ffi::c_int,
    >,
    pub read_dqblk: ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> ffi::c_int>,
    pub commit_dqblk: ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> ffi::c_int>,
    pub release_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> ffi::c_int>,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dquot_operations {
    pub write_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ffi::c_int>,
    pub alloc_dquot: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ffi::c_int) -> *mut dquot,
    >,
    pub destroy_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot)>,
    pub acquire_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ffi::c_int>,
    pub release_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ffi::c_int>,
    pub mark_dirty: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ffi::c_int>,
    pub write_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ffi::c_int) -> ffi::c_int,
    >,
    pub get_reserved_space:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut qsize_t>,
    pub get_projid: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut kprojid_t) -> ffi::c_int,
    >,
    pub get_inode_usage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut qsize_t) -> ffi::c_int,
    >,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_dqblk {
    pub d_fieldmask: ffi::c_int,
    pub d_spc_hardlimit: u64_,
    pub d_spc_softlimit: u64_,
    pub d_ino_hardlimit: u64_,
    pub d_ino_softlimit: u64_,
    pub d_space: u64_,
    pub d_ino_count: u64_,
    pub d_ino_timer: s64,
    pub d_spc_timer: s64,
    pub d_ino_warns: ffi::c_int,
    pub d_spc_warns: ffi::c_int,
    pub d_rt_spc_hardlimit: u64_,
    pub d_rt_spc_softlimit: u64_,
    pub d_rt_space: u64_,
    pub d_rt_spc_timer: s64,
    pub d_rt_spc_warns: ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_type_state {
    pub flags: ffi::c_uint,
    pub spc_timelimit: ffi::c_uint,
    pub ino_timelimit: ffi::c_uint,
    pub rt_spc_timelimit: ffi::c_uint,
    pub spc_warnlimit: ffi::c_uint,
    pub ino_warnlimit: ffi::c_uint,
    pub rt_spc_warnlimit: ffi::c_uint,
    pub ino: ffi::c_ulonglong,
    pub blocks: blkcnt_t,
    pub nextents: blkcnt_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_state {
    pub s_incoredqs: ffi::c_uint,
    pub s_state: [qc_type_state; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct qc_info {
    pub i_fieldmask: ffi::c_int,
    pub i_flags: ffi::c_uint,
    pub i_spc_timelimit: ffi::c_uint,
    pub i_ino_timelimit: ffi::c_uint,
    pub i_rt_spc_timelimit: ffi::c_uint,
    pub i_spc_warnlimit: ffi::c_uint,
    pub i_ino_warnlimit: ffi::c_uint,
    pub i_rt_spc_warnlimit: ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct quotactl_ops {
    pub quota_on: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ffi::c_int,
            arg3: ffi::c_int,
            arg4: *const path,
        ) -> ffi::c_int,
    >,
    pub quota_off: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ffi::c_int) -> ffi::c_int,
    >,
    pub quota_enable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ffi::c_uint) -> ffi::c_int,
    >,
    pub quota_disable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ffi::c_uint) -> ffi::c_int,
    >,
    pub quota_sync: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ffi::c_int) -> ffi::c_int,
    >,
    pub set_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ffi::c_int,
            arg3: *mut qc_info,
        ) -> ffi::c_int,
    >,
    pub get_dqblk: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: kqid, arg3: *mut qc_dqblk) -> ffi::c_int,
    >,
    pub get_nextdqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut kqid,
            arg3: *mut qc_dqblk,
        ) -> ffi::c_int,
    >,
    pub set_dqblk: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: kqid, arg3: *mut qc_dqblk) -> ffi::c_int,
    >,
    pub get_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut qc_state) -> ffi::c_int,
    >,
    pub rm_xquota: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ffi::c_uint) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quota_format_type {
    pub qf_fmt_id: ffi::c_int,
    pub qf_ops: *const quota_format_ops,
    pub qf_owner: *mut module,
    pub qf_next: *mut quota_format_type,
}
impl Default for quota_format_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_info {
    pub flags: ffi::c_uint,
    pub dqio_sem: rw_semaphore,
    pub files: [*mut inode; 3usize],
    pub info: [mem_dqinfo; 3usize],
    pub ops: [*const quota_format_ops; 3usize],
}
impl Default for quota_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct readahead_control {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kiocb {
    pub ki_filp: *mut file,
    pub ki_pos: loff_t,
    pub ki_complete:
        ::core::option::Option<unsafe extern "C" fn(iocb: *mut kiocb, ret: ffi::c_long)>,
    pub private: *mut ffi::c_void,
    pub ki_flags: ffi::c_int,
    pub ki_ioprio: u16_,
    pub ki_write_stream: u8_,
    pub __bindgen_anon_1: kiocb__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kiocb__bindgen_ty_1 {
    pub ki_waitq: *mut wait_page_queue,
    pub dio_complete: ::core::option::Option<unsafe extern "C" fn(data: *mut ffi::c_void) -> isize>,
}
impl Default for kiocb__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kiocb {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct address_space_operations {
    pub read_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut folio) -> ffi::c_int,
    >,
    pub writepages: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut writeback_control) -> ffi::c_int,
    >,
    pub dirty_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut folio) -> bool_,
    >,
    pub readahead: ::core::option::Option<unsafe extern "C" fn(arg1: *mut readahead_control)>,
    pub write_begin: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const kiocb,
            mapping: *mut address_space,
            pos: loff_t,
            len: ffi::c_uint,
            foliop: *mut *mut folio,
            fsdata: *mut *mut ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub write_end: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const kiocb,
            mapping: *mut address_space,
            pos: loff_t,
            len: ffi::c_uint,
            copied: ffi::c_uint,
            folio: *mut folio,
            fsdata: *mut ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub bmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: sector_t) -> sector_t,
    >,
    pub invalidate_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio, offset: usize, len: usize)>,
    pub release_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio, arg2: gfp_t) -> bool_>,
    pub free_folio: ::core::option::Option<unsafe extern "C" fn(folio: *mut folio)>,
    pub direct_IO: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, iter: *mut iov_iter) -> isize,
    >,
    pub migrate_folio: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            dst: *mut folio,
            src: *mut folio,
            arg2: migrate_mode,
        ) -> ffi::c_int,
    >,
    pub launder_folio: ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio) -> ffi::c_int>,
    pub is_partially_uptodate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut folio, from: usize, count: usize) -> bool_,
    >,
    pub is_dirty_writeback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut folio, dirty: *mut bool_, wb: *mut bool_),
    >,
    pub error_remove_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut folio) -> ffi::c_int,
    >,
    pub swap_activate: ::core::option::Option<
        unsafe extern "C" fn(
            sis: *mut swap_info_struct,
            file: *mut file,
            span: *mut sector_t,
        ) -> ffi::c_int,
    >,
    pub swap_deactivate: ::core::option::Option<unsafe extern "C" fn(file: *mut file)>,
    pub swap_rw: ::core::option::Option<
        unsafe extern "C" fn(iocb: *mut kiocb, iter: *mut iov_iter) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct address_space {
    pub host: *mut inode,
    pub i_pages: xarray,
    pub invalidate_lock: rw_semaphore,
    pub gfp_mask: gfp_t,
    pub i_mmap_writable: atomic_t,
    pub i_mmap: rb_root_cached,
    pub nrpages: ffi::c_ulong,
    pub writeback_index: ffi::c_ulong,
    pub a_ops: *const address_space_operations,
    pub flags: ffi::c_ulong,
    pub wb_err: errseq_t,
    pub i_private_lock: spinlock_t,
    pub i_private_list: list_head,
    pub i_mmap_rwsem: rw_semaphore,
    pub i_private_data: *mut ffi::c_void,
}
impl Default for address_space {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_acl {
    _unused: [u8; 0],
}
pub const inode_state_flags_t_I_NEW: inode_state_flags_t = 1;
pub const inode_state_flags_t_I_SYNC: inode_state_flags_t = 2;
pub const inode_state_flags_t_I_LRU_ISOLATING: inode_state_flags_t = 4;
pub const inode_state_flags_t_I_DIRTY_SYNC: inode_state_flags_t = 16;
pub const inode_state_flags_t_I_DIRTY_DATASYNC: inode_state_flags_t = 32;
pub const inode_state_flags_t_I_DIRTY_PAGES: inode_state_flags_t = 64;
pub const inode_state_flags_t_I_WILL_FREE: inode_state_flags_t = 128;
pub const inode_state_flags_t_I_FREEING: inode_state_flags_t = 256;
pub const inode_state_flags_t_I_CLEAR: inode_state_flags_t = 512;
pub const inode_state_flags_t_I_REFERENCED: inode_state_flags_t = 1024;
pub const inode_state_flags_t_I_LINKABLE: inode_state_flags_t = 2048;
pub const inode_state_flags_t_I_DIRTY_TIME: inode_state_flags_t = 4096;
pub const inode_state_flags_t_I_WB_SWITCH: inode_state_flags_t = 8192;
pub const inode_state_flags_t_I_OVL_INUSE: inode_state_flags_t = 16384;
pub const inode_state_flags_t_I_CREATING: inode_state_flags_t = 32768;
pub const inode_state_flags_t_I_DONTCACHE: inode_state_flags_t = 65536;
pub const inode_state_flags_t_I_SYNC_QUEUED: inode_state_flags_t = 131072;
pub const inode_state_flags_t_I_PINNING_NETFS_WB: inode_state_flags_t = 262144;
pub type inode_state_flags_t = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inode {
    pub i_mode: umode_t,
    pub i_opflags: ffi::c_ushort,
    pub i_uid: kuid_t,
    pub i_gid: kgid_t,
    pub i_flags: ffi::c_uint,
    pub i_acl: *mut posix_acl,
    pub i_default_acl: *mut posix_acl,
    pub i_op: *const inode_operations,
    pub i_sb: *mut super_block,
    pub i_mapping: *mut address_space,
    pub i_security: *mut ffi::c_void,
    pub i_ino: ffi::c_ulong,
    pub __bindgen_anon_1: inode__bindgen_ty_1,
    pub i_rdev: dev_t,
    pub i_size: loff_t,
    pub i_atime_sec: time64_t,
    pub i_mtime_sec: time64_t,
    pub i_ctime_sec: time64_t,
    pub i_atime_nsec: u32_,
    pub i_mtime_nsec: u32_,
    pub i_ctime_nsec: u32_,
    pub i_generation: u32_,
    pub i_lock: spinlock_t,
    pub i_bytes: ffi::c_ushort,
    pub i_blkbits: u8_,
    pub i_write_hint: rw_hint,
    pub i_blocks: blkcnt_t,
    pub i_state: inode_state_flags_t,
    pub i_rwsem: rw_semaphore,
    pub dirtied_when: ffi::c_ulong,
    pub dirtied_time_when: ffi::c_ulong,
    pub i_hash: hlist_node,
    pub i_io_list: list_head,
    pub i_lru: list_head,
    pub i_sb_list: list_head,
    pub i_wb_list: list_head,
    pub __bindgen_anon_2: inode__bindgen_ty_2,
    pub i_version: atomic64_t,
    pub i_sequence: atomic64_t,
    pub i_count: atomic_t,
    pub i_dio_count: atomic_t,
    pub i_writecount: atomic_t,
    pub i_readcount: atomic_t,
    pub __bindgen_anon_3: inode__bindgen_ty_3,
    pub i_flctx: *mut file_lock_context,
    pub i_data: address_space,
    pub __bindgen_anon_4: inode__bindgen_ty_4,
    pub __bindgen_anon_5: inode__bindgen_ty_5,
    pub i_fsnotify_mask: __u32,
    pub i_fsnotify_marks: *mut fsnotify_mark_connector,
    pub i_private: *mut ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_1 {
    pub i_nlink: ffi::c_uint,
    pub __i_nlink: ffi::c_uint,
}
impl Default for inode__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_2 {
    pub i_dentry: hlist_head,
    pub i_rcu: callback_head,
}
impl Default for inode__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_3 {
    pub i_fop: *const file_operations,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
}
impl Default for inode__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_4 {
    pub i_devices: list_head,
    pub i_linklen: ffi::c_int,
}
impl Default for inode__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_5 {
    pub i_pipe: *mut pipe_inode_info,
    pub i_cdev: *mut cdev,
    pub i_link: *mut ffi::c_char,
    pub i_dir_seq: ffi::c_uint,
}
impl Default for inode__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for inode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fown_struct {
    pub file: *mut file,
    pub lock: rwlock_t,
    pub pid: *mut pid,
    pub pid_type: pid_type,
    pub uid: kuid_t,
    pub euid: kuid_t,
    pub signum: ffi::c_int,
}
impl Default for fown_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct file_ra_state {
    pub start: ffi::c_ulong,
    pub size: ffi::c_uint,
    pub async_size: ffi::c_uint,
    pub ra_pages: ffi::c_uint,
    pub order: ffi::c_ushort,
    pub mmap_miss: ffi::c_ushort,
    pub prev_pos: loff_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file {
    pub f_lock: spinlock_t,
    pub f_mode: fmode_t,
    pub f_op: *const file_operations,
    pub f_mapping: *mut address_space,
    pub private_data: *mut ffi::c_void,
    pub f_inode: *mut inode,
    pub f_flags: ffi::c_uint,
    pub f_iocb_flags: ffi::c_uint,
    pub f_cred: *const cred,
    pub f_owner: *mut fown_struct,
    pub __bindgen_anon_1: file__bindgen_ty_1,
    pub __bindgen_anon_2: file__bindgen_ty_2,
    pub f_pos: loff_t,
    pub f_security: *mut ffi::c_void,
    pub f_wb_err: errseq_t,
    pub f_sb_err: errseq_t,
    pub f_ep: *mut hlist_head,
    pub __bindgen_anon_3: file__bindgen_ty_3,
    pub f_ref: file_ref_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file__bindgen_ty_1 {
    pub f_path: path,
    pub __f_path: path,
}
impl Default for file__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file__bindgen_ty_2 {
    pub f_pos_lock: mutex,
    pub f_pipe: u64_,
}
impl Default for file__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file__bindgen_ty_3 {
    pub f_task_work: callback_head,
    pub f_llist: llist_node,
    pub f_ra: file_ra_state,
    pub f_freeptr: freeptr_t,
}
impl Default for file__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type fl_owner_t = *mut ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_lock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_lease {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sb_writers {
    pub frozen: ffi::c_ushort,
    pub freeze_kcount: ffi::c_int,
    pub freeze_ucount: ffi::c_int,
    pub freeze_owner: *const ffi::c_void,
    pub rw_sem: [percpu_rw_semaphore; 3usize],
}
impl Default for sb_writers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mount {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct super_block {
    pub s_list: list_head,
    pub s_dev: dev_t,
    pub s_blocksize_bits: ffi::c_uchar,
    pub s_blocksize: ffi::c_ulong,
    pub s_maxbytes: loff_t,
    pub s_type: *mut file_system_type,
    pub s_op: *const super_operations,
    pub dq_op: *const dquot_operations,
    pub s_qcop: *const quotactl_ops,
    pub s_export_op: *const export_operations,
    pub s_flags: ffi::c_ulong,
    pub s_iflags: ffi::c_ulong,
    pub s_magic: ffi::c_ulong,
    pub s_root: *mut dentry,
    pub s_umount: rw_semaphore,
    pub s_count: ffi::c_int,
    pub s_active: atomic_t,
    pub s_security: *mut ffi::c_void,
    pub s_xattr: *const *mut xattr_handler,
    pub s_roots: hlist_bl_head,
    pub s_mounts: *mut mount,
    pub s_bdev: *mut block_device,
    pub s_bdev_file: *mut file,
    pub s_bdi: *mut backing_dev_info,
    pub s_mtd: *mut mtd_info,
    pub s_instances: hlist_node,
    pub s_quota_types: ffi::c_uint,
    pub s_dquot: quota_info,
    pub s_writers: sb_writers,
    pub s_fs_info: *mut ffi::c_void,
    pub s_time_gran: u32_,
    pub s_time_min: time64_t,
    pub s_time_max: time64_t,
    pub s_fsnotify_mask: u32_,
    pub s_fsnotify_info: *mut fsnotify_sb_info,
    pub s_id: [ffi::c_char; 32usize],
    pub s_uuid: uuid_t,
    pub s_uuid_len: u8_,
    pub s_sysfs_name: [ffi::c_char; 37usize],
    pub s_max_links: ffi::c_uint,
    pub s_d_flags: ffi::c_uint,
    pub s_vfs_rename_mutex: mutex,
    pub s_subtype: *const ffi::c_char,
    pub __s_d_op: *const dentry_operations,
    pub s_shrink: *mut shrinker,
    pub s_remove_count: atomic_long_t,
    pub s_readonly_remount: ffi::c_int,
    pub s_wb_err: errseq_t,
    pub s_dio_done_wq: *mut workqueue_struct,
    pub s_pins: hlist_head,
    pub s_user_ns: *mut user_namespace,
    pub s_dentry_lru: list_lru,
    pub s_inode_lru: list_lru,
    pub rcu: callback_head,
    pub destroy_work: work_struct,
    pub s_sync_lock: mutex,
    pub s_stack_depth: ffi::c_int,
    pub __bindgen_padding_0: u32,
    pub s_inode_list_lock: spinlock_t,
    pub s_inodes: list_head,
    pub s_inode_wblist_lock: spinlock_t,
    pub s_inodes_wb: list_head,
}
impl Default for super_block {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type filldir_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut dir_context,
        arg2: *const ffi::c_char,
        arg3: ffi::c_int,
        arg4: loff_t,
        arg5: u64_,
        arg6: ffi::c_uint,
    ) -> bool_,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dir_context {
    pub actor: filldir_t,
    pub pos: loff_t,
    pub count: ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_uring_cmd {
    _unused: [u8; 0],
}
pub type fop_flags_t = ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct inode_operations {
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry, arg3: ffi::c_uint) -> *mut dentry,
    >,
    pub get_link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut delayed_call,
        ) -> *const ffi::c_char,
    >,
    pub permission: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub get_inode_acl: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: ffi::c_int, arg3: bool_) -> *mut posix_acl,
    >,
    pub readlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut ffi::c_char,
            arg3: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
            arg5: bool_,
        ) -> ffi::c_int,
    >,
    pub link: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut inode, arg3: *mut dentry) -> ffi::c_int,
    >,
    pub unlink: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> ffi::c_int,
    >,
    pub symlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: *const ffi::c_char,
        ) -> ffi::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
        ) -> *mut dentry,
    >,
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> ffi::c_int,
    >,
    pub mknod: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
            arg5: dev_t,
        ) -> ffi::c_int,
    >,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: *mut inode,
            arg5: *mut dentry,
            arg6: ffi::c_uint,
        ) -> ffi::c_int,
    >,
    pub setattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut dentry,
            arg3: *mut iattr,
        ) -> ffi::c_int,
    >,
    pub getattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *const path,
            arg3: *mut kstat,
            arg4: u32_,
            arg5: ffi::c_uint,
        ) -> ffi::c_int,
    >,
    pub listxattr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut ffi::c_char, arg3: usize) -> isize,
    >,
    pub fiemap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut fiemap_extent_info,
            start: u64_,
            len: u64_,
        ) -> ffi::c_int,
    >,
    pub update_time: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: ffi::c_int) -> ffi::c_int,
    >,
    pub atomic_open: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut file,
            open_flag: ffi::c_uint,
            create_mode: umode_t,
        ) -> ffi::c_int,
    >,
    pub tmpfile: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut inode,
            arg3: *mut file,
            arg4: umode_t,
        ) -> ffi::c_int,
    >,
    pub get_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut dentry,
            arg3: ffi::c_int,
        ) -> *mut posix_acl,
    >,
    pub set_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mnt_idmap,
            arg2: *mut dentry,
            arg3: *mut posix_acl,
            arg4: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub fileattr_set: ::core::option::Option<
        unsafe extern "C" fn(
            idmap: *mut mnt_idmap,
            dentry: *mut dentry,
            fa: *mut file_kattr,
        ) -> ffi::c_int,
    >,
    pub fileattr_get: ::core::option::Option<
        unsafe extern "C" fn(dentry: *mut dentry, fa: *mut file_kattr) -> ffi::c_int,
    >,
    pub get_offset_ctx:
        ::core::option::Option<unsafe extern "C" fn(inode: *mut inode) -> *mut offset_ctx>,
}
impl Default for inode_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn generic_remap_file_range_prep(
        file_in: *mut file,
        pos_in: loff_t,
        file_out: *mut file,
        pos_out: loff_t,
        count: *mut loff_t,
        remap_flags: ffi::c_uint,
    ) -> ffi::c_int;
}
pub const freeze_holder_FREEZE_HOLDER_KERNEL: freeze_holder = 1;
pub const freeze_holder_FREEZE_HOLDER_USERSPACE: freeze_holder = 2;
pub const freeze_holder_FREEZE_MAY_NEST: freeze_holder = 4;
pub const freeze_holder_FREEZE_EXCL: freeze_holder = 8;
pub type freeze_holder = ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct super_operations {
    pub alloc_inode:
        ::core::option::Option<unsafe extern "C" fn(sb: *mut super_block) -> *mut inode>,
    pub destroy_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub dirty_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode, flags: ffi::c_int)>,
    pub write_inode: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, wbc: *mut writeback_control) -> ffi::c_int,
    >,
    pub drop_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> ffi::c_int>,
    pub evict_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub put_super: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub sync_fs: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, wait: ffi::c_int) -> ffi::c_int,
    >,
    pub freeze_super: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            who: freeze_holder,
            owner: *const ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub freeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> ffi::c_int>,
    pub thaw_super: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            who: freeze_holder,
            owner: *const ffi::c_void,
        ) -> ffi::c_int,
    >,
    pub unfreeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> ffi::c_int>,
    pub statfs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut kstatfs) -> ffi::c_int,
    >,
    pub remount_fs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut ffi::c_int,
            arg3: *mut ffi::c_char,
        ) -> ffi::c_int,
    >,
    pub umount_begin: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ffi::c_int,
    >,
    pub show_devname: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ffi::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ffi::c_int,
    >,
    pub show_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ffi::c_int,
    >,
    pub quota_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ffi::c_int,
            arg3: *mut ffi::c_char,
            arg4: usize,
            arg5: loff_t,
        ) -> isize,
    >,
    pub quota_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ffi::c_int,
            arg3: *const ffi::c_char,
            arg4: usize,
            arg5: loff_t,
        ) -> isize,
    >,
    pub get_dquots:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut *mut dquot>,
    pub nr_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut shrink_control) -> ffi::c_long,
    >,
    pub free_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut shrink_control) -> ffi::c_long,
    >,
    pub remove_bdev: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, bdev: *mut block_device) -> ffi::c_int,
    >,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(sb: *mut super_block)>,
}
unsafe extern "C" {
    pub fn set_nlink(inode: *mut inode, nlink: ffi::c_uint);
}
unsafe extern "C" {
    pub fn generic_shutdown_super(sb: *mut super_block);
}
unsafe extern "C" {
    pub fn generic_update_time(arg1: *mut inode, arg2: ffi::c_int) -> ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_names {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct filename {
    pub name: *const ffi::c_char,
    pub uptr: *const ffi::c_char,
    pub refcnt: atomic_t,
    pub aname: *mut audit_names,
    pub iname: __IncompleteArrayField<ffi::c_char>,
}
impl Default for filename {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn init_special_inode(arg1: *mut inode, arg2: umode_t, arg3: dev_t);
}
unsafe extern "C" {
    pub fn make_bad_inode(arg1: *mut inode);
}
unsafe extern "C" {
    pub fn is_bad_inode(arg1: *mut inode) -> bool_;
}
unsafe extern "C" {
    pub fn generic_permission(
        arg1: *mut mnt_idmap,
        arg2: *mut inode,
        arg3: ffi::c_int,
    ) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn unlock_new_inode(arg1: *mut inode);
}
unsafe extern "C" {
    pub fn discard_new_inode(arg1: *mut inode);
}
unsafe extern "C" {
    pub fn clear_inode(arg1: *mut inode);
}
unsafe extern "C" {
    pub fn __destroy_inode(arg1: *mut inode);
}
unsafe extern "C" {
    pub fn alloc_inode(sb: *mut super_block) -> *mut inode;
}
unsafe extern "C" {
    pub fn new_inode(sb: *mut super_block) -> *mut inode;
}
unsafe extern "C" {
    pub fn generic_file_mmap(arg1: *mut file, arg2: *mut vm_area_struct) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn generic_file_mmap_prepare(desc: *mut vm_area_desc) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn generic_file_readonly_mmap(arg1: *mut file, arg2: *mut vm_area_struct) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn generic_file_readonly_mmap_prepare(desc: *mut vm_area_desc) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn generic_write_checks(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
unsafe extern "C" {
    pub fn generic_write_checks_count(iocb: *mut kiocb, count: *mut loff_t) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn generic_write_check_limits(
        file: *mut file,
        pos: loff_t,
        count: *mut loff_t,
    ) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn generic_file_rw_checks(file_in: *mut file, file_out: *mut file) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn generic_file_read_iter(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
unsafe extern "C" {
    pub fn generic_file_write_iter(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
unsafe extern "C" {
    pub fn generic_file_direct_write(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
unsafe extern "C" {
    pub fn generic_perform_write(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
unsafe extern "C" {
    pub fn generic_file_llseek(file: *mut file, offset: loff_t, whence: ffi::c_int) -> loff_t;
}
unsafe extern "C" {
    pub fn generic_file_llseek_size(
        file: *mut file,
        offset: loff_t,
        whence: ffi::c_int,
        maxsize: loff_t,
        eof: loff_t,
    ) -> loff_t;
}
unsafe extern "C" {
    pub fn generic_llseek_cookie(
        file: *mut file,
        offset: loff_t,
        whence: ffi::c_int,
        cookie: *mut u64_,
    ) -> loff_t;
}
unsafe extern "C" {
    pub fn generic_file_open(inode: *mut inode, filp: *mut file) -> ffi::c_int;
}
unsafe extern "C" {
    pub static generic_ro_fops: file_operations;
}
unsafe extern "C" {
    pub fn page_get_link(
        arg1: *mut dentry,
        arg2: *mut inode,
        arg3: *mut delayed_call,
    ) -> *const ffi::c_char;
}
unsafe extern "C" {
    pub fn generic_fillattr(arg1: *mut mnt_idmap, arg2: u32_, arg3: *mut inode, arg4: *mut kstat);
}
unsafe extern "C" {
    pub fn generic_fill_statx_attr(inode: *mut inode, stat: *mut kstat);
}
unsafe extern "C" {
    pub fn generic_fill_statx_atomic_writes(
        stat: *mut kstat,
        unit_min: ffi::c_uint,
        unit_max: ffi::c_uint,
        unit_max_opt: ffi::c_uint,
    );
}
unsafe extern "C" {
    pub fn alloc_anon_inode(arg1: *mut super_block) -> *mut inode;
}
unsafe extern "C" {
    pub fn anon_inode_make_secure_inode(
        sb: *mut super_block,
        name: *const ffi::c_char,
        context_inode: *const inode,
    ) -> *mut inode;
}
unsafe extern "C" {
    pub fn generic_read_dir(
        arg1: *mut file,
        arg2: *mut ffi::c_char,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn make_empty_dir_inode(inode: *mut inode);
}
unsafe extern "C" {
    pub fn is_empty_dir_inode(inode: *mut inode) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct offset_ctx {
    pub mt: maple_tree,
    pub next_offset: ffi::c_ulong,
}
impl Default for offset_ctx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn generic_file_fsync(
        arg1: *mut file,
        arg2: loff_t,
        arg3: loff_t,
        arg4: ffi::c_int,
    ) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn generic_check_addressable(arg1: ffi::c_uint, arg2: u64_) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn generic_set_sb_d_ops(sb: *mut super_block);
}
unsafe extern "C" {
    pub fn generic_ci_match(
        parent: *const inode,
        name: *const qstr,
        folded_name: *const qstr,
        de_name: *const u8_,
        de_name_len: u32_,
    ) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn inode_nohighmem(inode: *mut inode);
}
unsafe extern "C" {
    pub fn generic_fadvise(
        file: *mut file,
        offset: loff_t,
        len: loff_t,
        advice: ffi::c_int,
    ) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn generic_atomic_write_valid(iocb: *mut kiocb, iter: *mut iov_iter) -> ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vmem_altmap {
    pub base_pfn: ffi::c_ulong,
    pub end_pfn: ffi::c_ulong,
    pub reserve: ffi::c_ulong,
    pub free: ffi::c_ulong,
    pub align: ffi::c_ulong,
    pub alloc: ffi::c_ulong,
    pub inaccessible: bool_,
}
pub const memory_type_MEMORY_DEVICE_PRIVATE: memory_type = 1;
pub const memory_type_MEMORY_DEVICE_COHERENT: memory_type = 2;
pub const memory_type_MEMORY_DEVICE_FS_DAX: memory_type = 3;
pub const memory_type_MEMORY_DEVICE_GENERIC: memory_type = 4;
pub const memory_type_MEMORY_DEVICE_PCI_P2PDMA: memory_type = 5;
pub type memory_type = ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dev_pagemap_ops {
    pub page_free: ::core::option::Option<unsafe extern "C" fn(page: *mut page)>,
    pub migrate_to_ram:
        ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub memory_failure: ::core::option::Option<
        unsafe extern "C" fn(
            pgmap: *mut dev_pagemap,
            pfn: ffi::c_ulong,
            nr_pages: ffi::c_ulong,
            mf_flags: ffi::c_int,
        ) -> ffi::c_int,
    >,
}
#[repr(C)]
pub struct dev_pagemap {
    pub altmap: vmem_altmap,
    pub ref_: percpu_ref,
    pub done: completion,
    pub type_: memory_type,
    pub flags: ffi::c_uint,
    pub vmemmap_shift: ffi::c_ulong,
    pub ops: *const dev_pagemap_ops,
    pub owner: *mut ffi::c_void,
    pub nr_range: ffi::c_int,
    pub __bindgen_anon_1: dev_pagemap__bindgen_ty_1,
}
#[repr(C)]
pub struct dev_pagemap__bindgen_ty_1 {
    pub range: __BindgenUnionField<range>,
    pub __bindgen_anon_1: __BindgenUnionField<dev_pagemap__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct dev_pagemap__bindgen_ty_1__bindgen_ty_1 {
    pub __empty_ranges: dev_pagemap__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub ranges: __IncompleteArrayField<range>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dev_pagemap__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
impl Default for dev_pagemap__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for dev_pagemap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct anon_vma {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_fault {
    pub __bindgen_anon_1: vm_fault__bindgen_ty_1,
    pub flags: fault_flag,
    pub pmd: *mut pmd_t,
    pub pud: *mut pud_t,
    pub __bindgen_anon_2: vm_fault__bindgen_ty_2,
    pub cow_page: *mut page,
    pub page: *mut page,
    pub pte: *mut pte_t,
    pub ptl: *mut spinlock_t,
    pub prealloc_pte: pgtable_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_fault__bindgen_ty_1 {
    pub vma: *mut vm_area_struct,
    pub gfp_mask: gfp_t,
    pub pgoff: ffi::c_ulong,
    pub address: ffi::c_ulong,
    pub real_address: ffi::c_ulong,
}
impl Default for vm_fault__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_fault__bindgen_ty_2 {
    pub orig_pte: pte_t,
    pub orig_pmd: pmd_t,
}
impl Default for vm_fault__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vm_fault {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vm_operations_struct {
    pub open: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
    pub close: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
    pub may_split: ::core::option::Option<
        unsafe extern "C" fn(area: *mut vm_area_struct, addr: ffi::c_ulong) -> ffi::c_int,
    >,
    pub mremap:
        ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct) -> ffi::c_int>,
    pub mprotect: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            start: ffi::c_ulong,
            end: ffi::c_ulong,
            newflags: ffi::c_ulong,
        ) -> ffi::c_int,
    >,
    pub fault: ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub huge_fault: ::core::option::Option<
        unsafe extern "C" fn(vmf: *mut vm_fault, order: ffi::c_uint) -> vm_fault_t,
    >,
    pub map_pages: ::core::option::Option<
        unsafe extern "C" fn(
            vmf: *mut vm_fault,
            start_pgoff: ffi::c_ulong,
            end_pgoff: ffi::c_ulong,
        ) -> vm_fault_t,
    >,
    pub pagesize:
        ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct) -> ffi::c_ulong>,
    pub page_mkwrite:
        ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub pfn_mkwrite: ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub access: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            addr: ffi::c_ulong,
            buf: *mut ffi::c_void,
            len: ffi::c_int,
            write: ffi::c_int,
        ) -> ffi::c_int,
    >,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct) -> *const ffi::c_char,
    >,
    pub set_policy: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct, new: *mut mempolicy) -> ffi::c_int,
    >,
    pub get_policy: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            addr: ffi::c_ulong,
            ilx: *mut ffi::c_ulong,
        ) -> *mut mempolicy,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct idr {
    pub idr_rt: xarray,
    pub idr_base: ffi::c_uint,
    pub idr_next: ffi::c_uint,
}
impl Default for idr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_open_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_iattrs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_dir {
    pub subdirs: ffi::c_ulong,
    pub children: rb_root,
    pub root: *mut kernfs_root,
    pub rev: ffi::c_ulong,
}
impl Default for kernfs_elem_dir {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_symlink {
    pub target_kn: *mut kernfs_node,
}
impl Default for kernfs_elem_symlink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernfs_elem_attr {
    pub ops: *const kernfs_ops,
    pub open: *mut kernfs_open_node,
    pub size: loff_t,
    pub notify_next: *mut kernfs_node,
}
impl Default for kernfs_elem_attr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_node {
    pub count: atomic_t,
    pub active: atomic_t,
    pub __parent: *mut kernfs_node,
    pub name: *const ffi::c_char,
    pub rb: rb_node,
    pub ns: *const ffi::c_void,
    pub hash: ffi::c_uint,
    pub flags: ffi::c_ushort,
    pub mode: umode_t,
    pub __bindgen_anon_1: kernfs_node__bindgen_ty_1,
    pub id: u64_,
    pub priv_: *mut ffi::c_void,
    pub iattr: *mut kernfs_iattrs,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernfs_node__bindgen_ty_1 {
    pub dir: kernfs_elem_dir,
    pub symlink: kernfs_elem_symlink,
    pub attr: kernfs_elem_attr,
}
impl Default for kernfs_node__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kernfs_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_file {
    pub kn: *mut kernfs_node,
    pub file: *mut file,
    pub seq_file: *mut seq_file,
    pub priv_: *mut ffi::c_void,
    pub mutex: mutex,
    pub prealloc_mutex: mutex,
    pub event: ffi::c_int,
    pub list: list_head,
    pub prealloc_buf: *mut ffi::c_char,
    pub atomic_write_len: usize,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub vm_ops: *const vm_operations_struct,
}
impl Default for kernfs_open_file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl kernfs_open_file {
    #[inline]
    pub fn mmapped(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mmapped(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mmapped_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mmapped_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn released(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_released(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn released_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_released_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(mmapped: bool_, released: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mmapped: u8 = unsafe { ::core::mem::transmute(mmapped) };
            mmapped as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let released: u8 = unsafe { ::core::mem::transmute(released) };
            released as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernfs_ops {
    pub open: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file) -> ffi::c_int>,
    pub release: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file)>,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, v: *mut ffi::c_void) -> ffi::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, ppos: *mut loff_t) -> *mut ffi::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            v: *mut ffi::c_void,
            ppos: *mut loff_t,
        ) -> *mut ffi::c_void,
    >,
    pub seq_stop:
        ::core::option::Option<unsafe extern "C" fn(sf: *mut seq_file, v: *mut ffi::c_void)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut ffi::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub atomic_write_len: usize,
    pub prealloc: bool_,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut ffi::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(of: *mut kernfs_open_file, pt: *mut poll_table_struct) -> __poll_t,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(of: *mut kernfs_open_file, vma: *mut vm_area_struct) -> ffi::c_int,
    >,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            offset: loff_t,
            whence: ffi::c_int,
        ) -> loff_t,
    >,
}
unsafe extern "C" {
    pub fn kernfs_get_inode(sb: *mut super_block, kn: *mut kernfs_node) -> *mut inode;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sock {
    _unused: [u8; 0],
}
pub const kobj_ns_type_KOBJ_NS_TYPE_NONE: kobj_ns_type = 0;
pub const kobj_ns_type_KOBJ_NS_TYPE_NET: kobj_ns_type = 1;
pub const kobj_ns_type_KOBJ_NS_TYPES: kobj_ns_type = 2;
pub type kobj_ns_type = ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobj_ns_type_operations {
    pub type_: kobj_ns_type,
    pub current_may_mount: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub grab_current_ns: ::core::option::Option<unsafe extern "C" fn() -> *mut ffi::c_void>,
    pub netlink_ns:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> *const ffi::c_void>,
    pub initial_ns: ::core::option::Option<unsafe extern "C" fn() -> *const ffi::c_void>,
    pub drop_ns: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ffi::c_void)>,
}
impl Default for kobj_ns_type_operations {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attribute {
    pub name: *const ffi::c_char,
    pub mode: umode_t,
}
impl Default for attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attribute_group {
    pub name: *const ffi::c_char,
    pub is_visible: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kobject, arg2: *mut attribute, arg3: ffi::c_int) -> umode_t,
    >,
    pub is_bin_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *const bin_attribute,
            arg3: ffi::c_int,
        ) -> umode_t,
    >,
    pub bin_size: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *const bin_attribute,
            arg3: ffi::c_int,
        ) -> usize,
    >,
    pub attrs: *mut *mut attribute,
    pub bin_attrs: *const *const bin_attribute,
}
impl Default for attribute_group {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bin_attribute {
    pub attr: attribute,
    pub size: usize,
    pub private: *mut ffi::c_void,
    pub f_mapping: ::core::option::Option<unsafe extern "C" fn() -> *mut address_space>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *const bin_attribute,
            arg4: *mut ffi::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *const bin_attribute,
            arg4: *mut ffi::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *const bin_attribute,
            arg4: loff_t,
            arg5: ffi::c_int,
        ) -> loff_t,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            attr: *const bin_attribute,
            vma: *mut vm_area_struct,
        ) -> ffi::c_int,
    >,
}
impl Default for bin_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sysfs_ops {
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *mut ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *const ffi::c_char,
            arg4: usize,
        ) -> isize,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobject {
    pub name: *const ffi::c_char,
    pub entry: list_head,
    pub parent: *mut kobject,
    pub kset: *mut kset,
    pub ktype: *const kobj_type,
    pub sd: *mut kernfs_node,
    pub kref: kref,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for kobject {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl kobject {
    #[inline]
    pub fn state_initialized(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_initialized(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_initialized_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_initialized_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state_in_sysfs(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_in_sysfs(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_in_sysfs_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_in_sysfs_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state_add_uevent_sent(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_add_uevent_sent(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_add_uevent_sent_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_add_uevent_sent_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state_remove_uevent_sent(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_remove_uevent_sent(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_remove_uevent_sent_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_state_remove_uevent_sent_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn uevent_suppress(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uevent_suppress(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn uevent_suppress_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_uevent_suppress_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state_initialized: ffi::c_uint,
        state_in_sysfs: ffi::c_uint,
        state_add_uevent_sent: ffi::c_uint,
        state_remove_uevent_sent: ffi::c_uint,
        uevent_suppress: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let state_initialized: u32 = unsafe { ::core::mem::transmute(state_initialized) };
            state_initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let state_in_sysfs: u32 = unsafe { ::core::mem::transmute(state_in_sysfs) };
            state_in_sysfs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let state_add_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_add_uevent_sent) };
            state_add_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_remove_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_remove_uevent_sent) };
            state_remove_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let uevent_suppress: u32 = unsafe { ::core::mem::transmute(uevent_suppress) };
            uevent_suppress as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobj_type {
    pub release: ::core::option::Option<unsafe extern "C" fn(kobj: *mut kobject)>,
    pub sysfs_ops: *const sysfs_ops,
    pub default_groups: *mut *const attribute_group,
    pub child_ns_type: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject) -> *const kobj_ns_type_operations,
    >,
    pub namespace:
        ::core::option::Option<unsafe extern "C" fn(kobj: *const kobject) -> *const ffi::c_void>,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
}
impl Default for kobj_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobj_uevent_env {
    pub argv: [*mut ffi::c_char; 3usize],
    pub envp: [*mut ffi::c_char; 64usize],
    pub envp_idx: ffi::c_int,
    pub buf: [ffi::c_char; 2048usize],
    pub buflen: ffi::c_int,
}
impl Default for kobj_uevent_env {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kset_uevent_ops {
    pub filter: ::core::option::Option<unsafe extern "C" fn(kobj: *const kobject) -> ffi::c_int>,
    pub name:
        ::core::option::Option<unsafe extern "C" fn(kobj: *const kobject) -> *const ffi::c_char>,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(kobj: *const kobject, env: *mut kobj_uevent_env) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kset {
    pub list: list_head,
    pub list_lock: spinlock_t,
    pub kobj: kobject,
    pub uevent_ops: *const kset_uevent_ops,
}
impl Default for kset {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn folio_copy(dst: *mut folio, src: *mut folio);
}
unsafe extern "C" {
    pub fn folio_mc_copy(dst: *mut folio, src: *mut folio) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn generic_access_phys(
        vma: *mut vm_area_struct,
        addr: ffi::c_ulong,
        buf: *mut ffi::c_void,
        len: ffi::c_int,
        write: ffi::c_int,
    ) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn generic_error_remove_folio(mapping: *mut address_space, folio: *mut folio)
    -> ffi::c_int;
}
unsafe extern "C" {
    pub fn folio_add_pins(folio: *mut folio, pins: ffi::c_uint) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn folio_add_pin(folio: *mut folio);
}
unsafe extern "C" {
    pub fn folio_mark_dirty(folio: *mut folio) -> bool_;
}
unsafe extern "C" {
    pub fn folio_mark_dirty_lock(folio: *mut folio) -> bool_;
}
unsafe extern "C" {
    pub fn folio_zero_user(folio: *mut folio, addr_hint: ffi::c_ulong);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct latch_tree_node {
    pub node: [rb_node; 2usize],
}
impl Default for latch_tree_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ffi::c_void,
    pub iov_len: __kernel_size_t,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct folio_queue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvec {
    pub iov_base: *mut ffi::c_void,
    pub iov_len: usize,
}
impl Default for kvec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iov_iter {
    pub iter_type: u8_,
    pub nofault: bool_,
    pub data_source: bool_,
    pub iov_offset: usize,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1,
    pub __bindgen_anon_2: iov_iter__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_1 {
    pub __ubuf_iovec: iovec,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iov_iter__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub count: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __iov: *const iovec,
    pub kvec: *const kvec,
    pub bvec: *const bio_vec,
    pub folioq: *const folio_queue,
    pub xarray: *mut xarray,
    pub ubuf: *mut ffi::c_void,
}
impl Default for iov_iter__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iov_iter__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iov_iter__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_2 {
    pub nr_segs: ffi::c_ulong,
    pub folioq_slot: u8_,
    pub xarray_start: loff_t,
}
impl Default for iov_iter__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for iov_iter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type compat_long_t = s32;
pub type compat_uptr_t = u32_;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct compat_robust_list {
    pub next: compat_uptr_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct compat_robust_list_head {
    pub list: compat_robust_list,
    pub futex_offset: compat_long_t,
    pub list_op_pending: compat_uptr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdso_image {
    pub data: *mut ffi::c_void,
    pub size: ffi::c_ulong,
    pub alt: ffi::c_ulong,
    pub alt_len: ffi::c_ulong,
    pub extable_base: ffi::c_ulong,
    pub extable_len: ffi::c_ulong,
    pub extable: *const ffi::c_void,
    pub sym_VDSO32_NOTE_MASK: ffi::c_long,
    pub sym___kernel_sigreturn: ffi::c_long,
    pub sym___kernel_rt_sigreturn: ffi::c_long,
    pub sym___kernel_vsyscall: ffi::c_long,
    pub sym_int80_landing_pad: ffi::c_long,
    pub sym_vdso32_sigreturn_landing_pad: ffi::c_long,
    pub sym_vdso32_rt_sigreturn_landing_pad: ffi::c_long,
}
impl Default for vdso_image {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Elf64_Addr = __u64;
pub type Elf64_Half = __u16;
pub type Elf64_Word = __u32;
pub type Elf64_Xword = __u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct elf64_sym {
    pub st_name: Elf64_Word,
    pub st_info: ffi::c_uchar,
    pub st_other: ffi::c_uchar,
    pub st_shndx: Elf64_Half,
    pub st_value: Elf64_Addr,
    pub st_size: Elf64_Xword,
}
pub type Elf64_Sym = elf64_sym;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernel_param_ops {
    pub flags: ffi::c_uint,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(val: *const ffi::c_char, kp: *const kernel_param) -> ffi::c_int,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(buffer: *mut ffi::c_char, kp: *const kernel_param) -> ffi::c_int,
    >,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg: *mut ffi::c_void)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_param {
    pub name: *const ffi::c_char,
    pub mod_: *mut module,
    pub ops: *const kernel_param_ops,
    pub perm: u16_,
    pub level: s8,
    pub flags: u8_,
    pub __bindgen_anon_1: kernel_param__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernel_param__bindgen_ty_1 {
    pub arg: *mut ffi::c_void,
    pub str_: *const kparam_string,
    pub arr: *const kparam_array,
}
impl Default for kernel_param__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for kernel_param {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kparam_string {
    pub maxlen: ffi::c_uint,
    pub string: *mut ffi::c_char,
}
impl Default for kparam_string {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kparam_array {
    pub max: ffi::c_uint,
    pub elemsize: ffi::c_uint,
    pub num: *mut ffi::c_uint,
    pub ops: *const kernel_param_ops,
    pub elem: *mut ffi::c_void,
}
impl Default for kparam_array {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct its_array {
    pub pages: *mut *mut ffi::c_void,
    pub num: ffi::c_int,
}
impl Default for its_array {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_arch_specific {
    pub num_orcs: ffi::c_uint,
    pub orc_unwind_ip: *mut ffi::c_int,
    pub orc_unwind: *mut orc_entry,
    pub its_pages: its_array,
}
impl Default for mod_arch_specific {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_kobject {
    pub kobj: kobject,
    pub mod_: *mut module,
    pub drivers_dir: *mut kobject,
    pub mp: *mut module_param_attrs,
    pub kobj_completion: *mut completion,
}
impl Default for module_kobject {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const module_attribute,
            arg2: *mut module_kobject,
            arg3: *mut ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const module_attribute,
            arg2: *mut module_kobject,
            arg3: *const ffi::c_char,
            count: usize,
        ) -> isize,
    >,
    pub setup:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut module, arg2: *const ffi::c_char)>,
    pub test: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module) -> ffi::c_int>,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module)>,
}
impl Default for module_attribute {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const module_state_MODULE_STATE_LIVE: module_state = 0;
pub const module_state_MODULE_STATE_COMING: module_state = 1;
pub const module_state_MODULE_STATE_GOING: module_state = 2;
pub const module_state_MODULE_STATE_UNFORMED: module_state = 3;
pub type module_state = ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_tree_node {
    pub mod_: *mut module,
    pub node: latch_tree_node,
}
impl Default for mod_tree_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_memory {
    pub base: *mut ffi::c_void,
    pub is_rox: bool_,
    pub size: ffi::c_uint,
    pub mtn: mod_tree_node,
}
impl Default for module_memory {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_kallsyms {
    pub symtab: *mut Elf64_Sym,
    pub num_symtab: ffi::c_uint,
    pub strtab: *mut ffi::c_char,
    pub typetab: *mut ffi::c_char,
}
impl Default for mod_kallsyms {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pm_message {
    pub event: ffi::c_int,
}
pub type pm_message_t = pm_message;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dev_pm_ops {
    pub prepare: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub complete: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub freeze: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub thaw: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub poweroff: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub restore: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub suspend_late: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub resume_early: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub freeze_late: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub thaw_early: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub poweroff_late: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub restore_early: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub suspend_noirq: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub resume_noirq: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub freeze_noirq: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub thaw_noirq: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub poweroff_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub restore_noirq: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub runtime_suspend:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub runtime_resume:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub runtime_idle: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
}
pub const rpm_status_RPM_INVALID: rpm_status = -1;
pub const rpm_status_RPM_ACTIVE: rpm_status = 0;
pub const rpm_status_RPM_RESUMING: rpm_status = 1;
pub const rpm_status_RPM_SUSPENDED: rpm_status = 2;
pub const rpm_status_RPM_SUSPENDING: rpm_status = 3;
pub const rpm_status_RPM_BLOCKED: rpm_status = 4;
pub type rpm_status = ffi::c_int;
pub const rpm_request_RPM_REQ_NONE: rpm_request = 0;
pub const rpm_request_RPM_REQ_IDLE: rpm_request = 1;
pub const rpm_request_RPM_REQ_SUSPEND: rpm_request = 2;
pub const rpm_request_RPM_REQ_AUTOSUSPEND: rpm_request = 3;
pub const rpm_request_RPM_REQ_RESUME: rpm_request = 4;
pub type rpm_request = ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wake_irq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_subsys_data {
    pub lock: spinlock_t,
    pub refcount: ffi::c_uint,
}
impl Default for pm_subsys_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_info {
    pub power_state: pm_message_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub driver_flags: u32_,
    pub lock: spinlock_t,
    pub entry: list_head,
    pub completion: completion,
    pub wakeup: *mut wakeup_source,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub suspend_timer: hrtimer,
    pub timer_expires: u64_,
    pub work: work_struct,
    pub wait_queue: wait_queue_head_t,
    pub wakeirq: *mut wake_irq,
    pub usage_count: atomic_t,
    pub child_count: atomic_t,
    pub _bitfield_align_3: [u8; 0],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub links_count: ffi::c_uint,
    pub request: rpm_request,
    pub runtime_status: rpm_status,
    pub last_status: rpm_status,
    pub runtime_error: ffi::c_int,
    pub autosuspend_delay: ffi::c_int,
    pub last_busy: u64_,
    pub active_time: u64_,
    pub suspended_time: u64_,
    pub accounting_timestamp: u64_,
    pub subsys_data: *mut pm_subsys_data,
    pub set_latency_tolerance:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: s32)>,
    pub qos: *mut dev_pm_qos,
    pub _bitfield_align_4: [u8; 0],
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl Default for dev_pm_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl dev_pm_info {
    #[inline]
    pub fn can_wakeup(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_can_wakeup(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn can_wakeup_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_can_wakeup_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn async_suspend(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_async_suspend(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn async_suspend_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_async_suspend_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_dpm_list(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_in_dpm_list(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_dpm_list_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_in_dpm_list_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_prepared(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_prepared(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_prepared_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_prepared_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_suspended_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_suspended_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_noirq_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_noirq_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_noirq_suspended_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_noirq_suspended_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_late_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_late_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_late_suspended_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_late_suspended_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_pm(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_pm_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_no_pm_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn early_init(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn early_init_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_early_init_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn direct_complete(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_direct_complete(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn direct_complete_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_direct_complete_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        can_wakeup: bool_,
        async_suspend: bool_,
        in_dpm_list: bool_,
        is_prepared: bool_,
        is_suspended: bool_,
        is_noirq_suspended: bool_,
        is_late_suspended: bool_,
        no_pm: bool_,
        early_init: bool_,
        direct_complete: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let can_wakeup: u8 = unsafe { ::core::mem::transmute(can_wakeup) };
            can_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let async_suspend: u8 = unsafe { ::core::mem::transmute(async_suspend) };
            async_suspend as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let in_dpm_list: u8 = unsafe { ::core::mem::transmute(in_dpm_list) };
            in_dpm_list as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_prepared: u8 = unsafe { ::core::mem::transmute(is_prepared) };
            is_prepared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_suspended: u8 = unsafe { ::core::mem::transmute(is_suspended) };
            is_suspended as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_noirq_suspended: u8 = unsafe { ::core::mem::transmute(is_noirq_suspended) };
            is_noirq_suspended as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is_late_suspended: u8 = unsafe { ::core::mem::transmute(is_late_suspended) };
            is_late_suspended as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let no_pm: u8 = unsafe { ::core::mem::transmute(no_pm) };
            no_pm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
            early_init as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let direct_complete: u8 = unsafe { ::core::mem::transmute(direct_complete) };
            direct_complete as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn wakeup_path(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wakeup_path(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wakeup_path_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_wakeup_path_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn syscore(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syscore(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn syscore_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_syscore_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_pm_callbacks(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm_callbacks(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_pm_callbacks_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_no_pm_callbacks_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn work_in_progress(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_work_in_progress(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn work_in_progress_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_work_in_progress_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn smart_suspend(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_smart_suspend(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn smart_suspend_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_smart_suspend_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn must_resume(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_must_resume(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn must_resume_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_must_resume_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn may_skip_resume(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_may_skip_resume(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn may_skip_resume_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_may_skip_resume_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn strict_midlayer(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_strict_midlayer(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn strict_midlayer_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_2),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_strict_midlayer_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_2),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        wakeup_path: bool_,
        syscore: bool_,
        no_pm_callbacks: bool_,
        work_in_progress: bool_,
        smart_suspend: bool_,
        must_resume: bool_,
        may_skip_resume: bool_,
        strict_midlayer: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wakeup_path: u8 = unsafe { ::core::mem::transmute(wakeup_path) };
            wakeup_path as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let syscore: u8 = unsafe { ::core::mem::transmute(syscore) };
            syscore as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_pm_callbacks: u8 = unsafe { ::core::mem::transmute(no_pm_callbacks) };
            no_pm_callbacks as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let work_in_progress: u8 = unsafe { ::core::mem::transmute(work_in_progress) };
            work_in_progress as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let smart_suspend: u8 = unsafe { ::core::mem::transmute(smart_suspend) };
            smart_suspend as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let must_resume: u8 = unsafe { ::core::mem::transmute(must_resume) };
            must_resume as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let may_skip_resume: u8 = unsafe { ::core::mem::transmute(may_skip_resume) };
            may_skip_resume as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let strict_midlayer: u8 = unsafe { ::core::mem::transmute(strict_midlayer) };
            strict_midlayer as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn disable_depth(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_disable_depth(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn disable_depth_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                0usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_disable_depth_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn idle_notification(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_idle_notification(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn idle_notification_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_idle_notification_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn request_pending(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_request_pending(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn request_pending_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_request_pending_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn deferred_resume(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_deferred_resume(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn deferred_resume_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_deferred_resume_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn needs_force_resume(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_needs_force_resume(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn needs_force_resume_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_needs_force_resume_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn runtime_auto(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_runtime_auto(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn runtime_auto_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_runtime_auto_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ignore_children(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_children(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ignore_children_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                8usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ignore_children_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_callbacks(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_callbacks(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_callbacks_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                9usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_no_callbacks_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn irq_safe(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_irq_safe(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn irq_safe_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                10usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_irq_safe_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn use_autosuspend(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_autosuspend(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_autosuspend_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                11usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_use_autosuspend_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn timer_autosuspends(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_timer_autosuspends(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn timer_autosuspends_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                12usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_timer_autosuspends_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn memalloc_noio(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_memalloc_noio(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn memalloc_noio_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_3),
                13usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_memalloc_noio_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_3),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        disable_depth: ffi::c_uint,
        idle_notification: bool_,
        request_pending: bool_,
        deferred_resume: bool_,
        needs_force_resume: bool_,
        runtime_auto: bool_,
        ignore_children: bool_,
        no_callbacks: bool_,
        irq_safe: bool_,
        use_autosuspend: bool_,
        timer_autosuspends: bool_,
        memalloc_noio: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let disable_depth: u32 = unsafe { ::core::mem::transmute(disable_depth) };
            disable_depth as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let idle_notification: u8 = unsafe { ::core::mem::transmute(idle_notification) };
            idle_notification as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let request_pending: u8 = unsafe { ::core::mem::transmute(request_pending) };
            request_pending as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let deferred_resume: u8 = unsafe { ::core::mem::transmute(deferred_resume) };
            deferred_resume as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let needs_force_resume: u8 = unsafe { ::core::mem::transmute(needs_force_resume) };
            needs_force_resume as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let runtime_auto: u8 = unsafe { ::core::mem::transmute(runtime_auto) };
            runtime_auto as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ignore_children: u8 = unsafe { ::core::mem::transmute(ignore_children) };
            ignore_children as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let no_callbacks: u8 = unsafe { ::core::mem::transmute(no_callbacks) };
            no_callbacks as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let irq_safe: u8 = unsafe { ::core::mem::transmute(irq_safe) };
            irq_safe as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let use_autosuspend: u8 = unsafe { ::core::mem::transmute(use_autosuspend) };
            use_autosuspend as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let timer_autosuspends: u8 = unsafe { ::core::mem::transmute(timer_autosuspends) };
            timer_autosuspends as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let memalloc_noio: u8 = unsafe { ::core::mem::transmute(memalloc_noio) };
            memalloc_noio as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn detach_power_off(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_detach_power_off(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_4.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn detach_power_off_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_4),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_detach_power_off_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_4),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_4(detach_power_off: bool_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let detach_power_off: u8 = unsafe { ::core::mem::transmute(detach_power_off) };
            detach_power_off as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dev_pm_domain {
    pub ops: dev_pm_ops,
    pub start: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub detach: ::core::option::Option<unsafe extern "C" fn(dev: *mut device, power_off: bool_)>,
    pub activate: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub sync: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub dismiss: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub set_performance_state: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: ffi::c_uint) -> ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_handle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_type {
    pub name: *const ffi::c_char,
    pub dev_name: *const ffi::c_char,
    pub bus_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub drv_groups: *mut *const attribute_group,
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, drv: *const device_driver) -> ffi::c_int,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, env: *mut kobj_uevent_env) -> ffi::c_int,
    >,
    pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub sync_state: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub irq_get_affinity: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, irq_vec: ffi::c_uint) -> *const cpumask,
    >,
    pub online: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub offline: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> ffi::c_int,
    >,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub num_vf: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub dma_configure: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub dma_cleanup: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub pm: *const dev_pm_ops,
    pub need_parent_lock: bool_,
}
impl Default for bus_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct class {
    pub name: *const ffi::c_char,
    pub class_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub dev_uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, env: *mut kobj_uevent_env) -> ffi::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, mode: *mut umode_t) -> *mut ffi::c_char,
    >,
    pub class_release: ::core::option::Option<unsafe extern "C" fn(class: *const class)>,
    pub dev_release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub shutdown_pre: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub ns_type: *const kobj_ns_type_operations,
    pub namespace:
        ::core::option::Option<unsafe extern "C" fn(dev: *const device) -> *const ffi::c_void>,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
    pub pm: *const dev_pm_ops,
}
impl Default for class {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const probe_type_PROBE_DEFAULT_STRATEGY: probe_type = 0;
pub const probe_type_PROBE_PREFER_ASYNCHRONOUS: probe_type = 1;
pub const probe_type_PROBE_FORCE_SYNCHRONOUS: probe_type = 2;
pub type probe_type = ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_driver {
    pub name: *const ffi::c_char,
    pub bus: *const bus_type,
    pub owner: *mut module,
    pub mod_name: *const ffi::c_char,
    pub suppress_bind_attrs: bool_,
    pub probe_type: probe_type,
    pub of_match_table: *mut of_device_id,
    pub acpi_match_table: *mut acpi_device_id,
    pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub sync_state: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> ffi::c_int,
    >,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> ffi::c_int>,
    pub groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub pm: *const dev_pm_ops,
    pub coredump: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub p: *mut driver_private,
}
impl Default for device_driver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dev_archdata {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct driver_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iommu_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_iommu {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msi_device_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_type {
    pub name: *const ffi::c_char,
    pub groups: *mut *const attribute_group,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *const device, env: *mut kobj_uevent_env) -> ffi::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *const device,
            mode: *mut umode_t,
            uid: *mut kuid_t,
            gid: *mut kgid_t,
        ) -> *mut ffi::c_char,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub pm: *const dev_pm_ops,
}
impl Default for device_type {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct device_dma_parameters {
    pub max_segment_size: ffi::c_uint,
    pub min_align_mask: ffi::c_uint,
    pub segment_boundary_mask: ffi::c_ulong,
}
pub const dl_dev_state_DL_DEV_NO_DRIVER: dl_dev_state = 0;
pub const dl_dev_state_DL_DEV_PROBING: dl_dev_state = 1;
pub const dl_dev_state_DL_DEV_DRIVER_BOUND: dl_dev_state = 2;
pub const dl_dev_state_DL_DEV_UNBINDING: dl_dev_state = 3;
pub type dl_dev_state = ffi::c_uint;
pub const device_removable_DEVICE_REMOVABLE_NOT_SUPPORTED: device_removable = 0;
pub const device_removable_DEVICE_REMOVABLE_UNKNOWN: device_removable = 1;
pub const device_removable_DEVICE_FIXED: device_removable = 2;
pub const device_removable_DEVICE_REMOVABLE: device_removable = 3;
pub type device_removable = ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_links_info {
    pub suppliers: list_head,
    pub consumers: list_head,
    pub defer_sync: list_head,
    pub status: dl_dev_state,
}
impl Default for dev_links_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_msi_info {
    pub domain: *mut irq_domain,
    pub data: *mut msi_device_data,
}
impl Default for dev_msi_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const device_physical_location_panel_DEVICE_PANEL_TOP: device_physical_location_panel = 0;
pub const device_physical_location_panel_DEVICE_PANEL_BOTTOM: device_physical_location_panel = 1;
pub const device_physical_location_panel_DEVICE_PANEL_LEFT: device_physical_location_panel = 2;
pub const device_physical_location_panel_DEVICE_PANEL_RIGHT: device_physical_location_panel = 3;
pub const device_physical_location_panel_DEVICE_PANEL_FRONT: device_physical_location_panel = 4;
pub const device_physical_location_panel_DEVICE_PANEL_BACK: device_physical_location_panel = 5;
pub const device_physical_location_panel_DEVICE_PANEL_UNKNOWN: device_physical_location_panel = 6;
pub type device_physical_location_panel = ffi::c_uint;
pub const device_physical_location_vertical_position_DEVICE_VERT_POS_UPPER:
    device_physical_location_vertical_position = 0;
pub const device_physical_location_vertical_position_DEVICE_VERT_POS_CENTER:
    device_physical_location_vertical_position = 1;
pub const device_physical_location_vertical_position_DEVICE_VERT_POS_LOWER:
    device_physical_location_vertical_position = 2;
pub type device_physical_location_vertical_position = ffi::c_uint;
pub const device_physical_location_horizontal_position_DEVICE_HORI_POS_LEFT:
    device_physical_location_horizontal_position = 0;
pub const device_physical_location_horizontal_position_DEVICE_HORI_POS_CENTER:
    device_physical_location_horizontal_position = 1;
pub const device_physical_location_horizontal_position_DEVICE_HORI_POS_RIGHT:
    device_physical_location_horizontal_position = 2;
pub type device_physical_location_horizontal_position = ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_physical_location {
    pub panel: device_physical_location_panel,
    pub vertical_position: device_physical_location_vertical_position,
    pub horizontal_position: device_physical_location_horizontal_position,
    pub dock: bool_,
    pub lid: bool_,
}
impl Default for device_physical_location {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device {
    pub kobj: kobject,
    pub parent: *mut device,
    pub p: *mut device_private,
    pub init_name: *const ffi::c_char,
    pub type_: *const device_type,
    pub bus: *const bus_type,
    pub driver: *mut device_driver,
    pub platform_data: *mut ffi::c_void,
    pub driver_data: *mut ffi::c_void,
    pub mutex: mutex,
    pub links: dev_links_info,
    pub power: dev_pm_info,
    pub pm_domain: *mut dev_pm_domain,
    pub msi: dev_msi_info,
    pub dma_mask: *mut u64_,
    pub coherent_dma_mask: u64_,
    pub bus_dma_limit: u64_,
    pub dma_range_map: *mut bus_dma_region,
    pub dma_parms: *mut device_dma_parameters,
    pub dma_pools: list_head,
    pub dma_io_tlb_mem: *mut io_tlb_mem,
    pub archdata: dev_archdata,
    pub of_node: *mut device_node,
    pub fwnode: *mut fwnode_handle,
    pub numa_node: ffi::c_int,
    pub devt: dev_t,
    pub id: u32_,
    pub devres_lock: spinlock_t,
    pub devres_head: list_head,
    pub class: *const class,
    pub groups: *mut *const attribute_group,
    pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub iommu_group: *mut iommu_group,
    pub iommu: *mut dev_iommu,
    pub physical_location: *mut device_physical_location,
    pub removable: device_removable,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl device {
    #[inline]
    pub fn offline_disabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline_disabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offline_disabled_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_offline_disabled_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn offline(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn offline_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_offline_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn of_node_reused(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_of_node_reused(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn of_node_reused_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_of_node_reused_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn state_synced(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_state_synced(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn state_synced_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_state_synced_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn can_match(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_can_match(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn can_match_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_can_match_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dma_skip_sync(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dma_skip_sync(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dma_skip_sync_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dma_skip_sync_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dma_iommu(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dma_iommu(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dma_iommu_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dma_iommu_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        offline_disabled: bool_,
        offline: bool_,
        of_node_reused: bool_,
        state_synced: bool_,
        can_match: bool_,
        dma_skip_sync: bool_,
        dma_iommu: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let offline_disabled: u8 = unsafe { ::core::mem::transmute(offline_disabled) };
            offline_disabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offline: u8 = unsafe { ::core::mem::transmute(offline) };
            offline as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let of_node_reused: u8 = unsafe { ::core::mem::transmute(of_node_reused) };
            of_node_reused as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_synced: u8 = unsafe { ::core::mem::transmute(state_synced) };
            state_synced as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let can_match: u8 = unsafe { ::core::mem::transmute(can_match) };
            can_match as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dma_skip_sync: u8 = unsafe { ::core::mem::transmute(dma_skip_sync) };
            dma_skip_sync as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let dma_iommu: u8 = unsafe { ::core::mem::transmute(dma_iommu) };
            dma_iommu as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wakeup_source {
    pub name: *const ffi::c_char,
    pub id: ffi::c_int,
    pub entry: list_head,
    pub lock: spinlock_t,
    pub wakeirq: *mut wake_irq,
    pub timer: timer_list,
    pub timer_expires: ffi::c_ulong,
    pub total_time: ktime_t,
    pub max_time: ktime_t,
    pub last_time: ktime_t,
    pub start_prevent_time: ktime_t,
    pub prevent_sleep_time: ktime_t,
    pub event_count: ffi::c_ulong,
    pub active_count: ffi::c_ulong,
    pub relax_count: ffi::c_ulong,
    pub expire_count: ffi::c_ulong,
    pub wakeup_count: ffi::c_ulong,
    pub dev: *mut device,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl Default for wakeup_source {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl wakeup_source {
    #[inline]
    pub fn active(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_active(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn active_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_active_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn autosleep_enabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_autosleep_enabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn autosleep_enabled_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_autosleep_enabled_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active: bool_,
        autosleep_enabled: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let active: u8 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let autosleep_enabled: u8 = unsafe { ::core::mem::transmute(autosleep_enabled) };
            autosleep_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct taskstats {
    pub version: __u16,
    pub ac_exitcode: __u32,
    pub ac_flag: __u8,
    pub ac_nice: __u8,
    pub cpu_count: __u64,
    pub cpu_delay_total: __u64,
    pub blkio_count: __u64,
    pub blkio_delay_total: __u64,
    pub swapin_count: __u64,
    pub swapin_delay_total: __u64,
    pub cpu_run_real_total: __u64,
    pub cpu_run_virtual_total: __u64,
    pub ac_comm: [ffi::c_char; 32usize],
    pub ac_sched: __u8,
    pub ac_pad: [__u8; 3usize],
    pub __bindgen_padding_0: u32,
    pub ac_uid: __u32,
    pub ac_gid: __u32,
    pub ac_pid: __u32,
    pub ac_ppid: __u32,
    pub ac_btime: __u32,
    pub ac_etime: __u64,
    pub ac_utime: __u64,
    pub ac_stime: __u64,
    pub ac_minflt: __u64,
    pub ac_majflt: __u64,
    pub coremem: __u64,
    pub virtmem: __u64,
    pub hiwater_rss: __u64,
    pub hiwater_vm: __u64,
    pub read_char: __u64,
    pub write_char: __u64,
    pub read_syscalls: __u64,
    pub write_syscalls: __u64,
    pub read_bytes: __u64,
    pub write_bytes: __u64,
    pub cancelled_write_bytes: __u64,
    pub nvcsw: __u64,
    pub nivcsw: __u64,
    pub ac_utimescaled: __u64,
    pub ac_stimescaled: __u64,
    pub cpu_scaled_run_real_total: __u64,
    pub freepages_count: __u64,
    pub freepages_delay_total: __u64,
    pub thrashing_count: __u64,
    pub thrashing_delay_total: __u64,
    pub ac_btime64: __u64,
    pub compact_count: __u64,
    pub compact_delay_total: __u64,
    pub ac_tgid: __u32,
    pub ac_tgetime: __u64,
    pub ac_exe_dev: __u64,
    pub ac_exe_inode: __u64,
    pub wpcopy_count: __u64,
    pub wpcopy_delay_total: __u64,
    pub irq_count: __u64,
    pub irq_delay_total: __u64,
    pub cpu_delay_max: __u64,
    pub cpu_delay_min: __u64,
    pub blkio_delay_max: __u64,
    pub blkio_delay_min: __u64,
    pub swapin_delay_max: __u64,
    pub swapin_delay_min: __u64,
    pub freepages_delay_max: __u64,
    pub freepages_delay_min: __u64,
    pub thrashing_delay_max: __u64,
    pub thrashing_delay_min: __u64,
    pub compact_delay_max: __u64,
    pub compact_delay_min: __u64,
    pub wpcopy_delay_max: __u64,
    pub wpcopy_delay_min: __u64,
    pub irq_delay_max: __u64,
    pub irq_delay_min: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seq_file {
    pub buf: *mut ffi::c_char,
    pub size: usize,
    pub from: usize,
    pub count: usize,
    pub pad_until: usize,
    pub index: loff_t,
    pub read_pos: loff_t,
    pub lock: mutex,
    pub op: *const seq_operations,
    pub poll_event: ffi::c_int,
    pub file: *const file,
    pub private: *mut ffi::c_void,
}
impl Default for seq_file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ns_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipc_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mnt_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct time_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uts_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_namespace {
    pub ns: ns_common,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub root_cset: *mut css_set,
}
impl Default for cgroup_namespace {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ns_common {
    pub ns_type: u32_,
    pub stashed: *mut dentry,
    pub ops: *const proc_ns_operations,
    pub inum: ffi::c_uint,
    pub __ns_ref: refcount_t,
    pub __bindgen_anon_1: ns_common__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ns_common__bindgen_ty_1 {
    pub __bindgen_anon_1: ns_common__bindgen_ty_1__bindgen_ty_1,
    pub ns_rcu: callback_head,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ns_common__bindgen_ty_1__bindgen_ty_1 {
    pub ns_id: u64_,
    pub ns_tree_node: rb_node,
    pub ns_list_node: list_head,
}
impl Default for ns_common__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ns_common__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ns_common {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsproxy {
    pub count: refcount_t,
    pub uts_ns: *mut uts_namespace,
    pub ipc_ns: *mut ipc_namespace,
    pub mnt_ns: *mut mnt_namespace,
    pub pid_ns_for_children: *mut pid_namespace,
    pub net_ns: *mut net,
    pub time_ns: *mut time_namespace,
    pub time_ns_for_children: *mut time_namespace,
    pub cgroup_ns: *mut cgroup_namespace,
}
impl Default for nsproxy {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uid_gid_extent {
    pub first: u32_,
    pub lower_first: u32_,
    pub count: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uid_gid_map {
    pub __bindgen_anon_1: uid_gid_map__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uid_gid_map__bindgen_ty_1 {
    pub __bindgen_anon_1: uid_gid_map__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: uid_gid_map__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uid_gid_map__bindgen_ty_1__bindgen_ty_1 {
    pub extent: [uid_gid_extent; 5usize],
    pub nr_extents: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uid_gid_map__bindgen_ty_1__bindgen_ty_2 {
    pub forward: *mut uid_gid_extent,
    pub reverse: *mut uid_gid_extent,
}
impl Default for uid_gid_map__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for uid_gid_map__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for uid_gid_map {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct binfmt_misc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucounts {
    pub node: hlist_nulls_node,
    pub ns: *mut user_namespace,
    pub uid: kuid_t,
    pub rcu: callback_head,
    pub count: rcuref_t,
    pub ucount: [atomic_long_t; 10usize],
    pub rlimit: [atomic_long_t; 4usize],
}
impl Default for ucounts {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct u64_stats_sync {}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cgroup_bpf {}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct psi_group {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_taskset {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_file {
    pub kn: *mut kernfs_node,
    pub notified_at: ffi::c_ulong,
    pub notify_timer: timer_list,
}
impl Default for cgroup_file {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup_subsys_state {
    pub cgroup: *mut cgroup,
    pub ss: *mut cgroup_subsys,
    pub refcnt: percpu_ref,
    pub rstat_cpu: *mut css_rstat_cpu,
    pub sibling: list_head,
    pub children: list_head,
    pub id: ffi::c_int,
    pub flags: ffi::c_uint,
    pub serial_nr: u64_,
    pub online_cnt: atomic_t,
    pub destroy_work: work_struct,
    pub destroy_rwork: rcu_work,
    pub parent: *mut cgroup_subsys_state,
    pub nr_descendants: ffi::c_int,
    pub rstat_flush_next: *mut cgroup_subsys_state,
}
impl Default for cgroup_subsys_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct css_set {
    pub subsys: [*mut cgroup_subsys_state; 14usize],
    pub refcount: refcount_t,
    pub dom_cset: *mut css_set,
    pub dfl_cgrp: *mut cgroup,
    pub nr_tasks: ffi::c_int,
    pub tasks: list_head,
    pub mg_tasks: list_head,
    pub dying_tasks: list_head,
    pub task_iters: list_head,
    pub e_cset_node: [list_head; 14usize],
    pub threaded_csets: list_head,
    pub threaded_csets_node: list_head,
    pub hlist: hlist_node,
    pub cgrp_links: list_head,
    pub mg_src_preload_node: list_head,
    pub mg_dst_preload_node: list_head,
    pub mg_node: list_head,
    pub mg_src_cgrp: *mut cgroup,
    pub mg_dst_cgrp: *mut cgroup,
    pub mg_dst_cset: *mut css_set,
    pub dead: bool_,
    pub callback_head: callback_head,
}
impl Default for css_set {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cgroup_base_stat {
    pub cputime: task_cputime,
    pub ntime: u64_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct css_rstat_cpu {
    pub updated_children: *mut cgroup_subsys_state,
    pub updated_next: *mut cgroup_subsys_state,
    pub lnode: llist_node,
    pub owner: *mut cgroup_subsys_state,
}
impl Default for css_rstat_cpu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cgroup_rstat_base_cpu {
    pub bsync: u64_stats_sync,
    pub bstat: cgroup_base_stat,
    pub last_bstat: cgroup_base_stat,
    pub subtree_bstat: cgroup_base_stat,
    pub last_subtree_bstat: cgroup_base_stat,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cgroup_freezer_state {
    pub freeze: bool_,
    pub e_freeze: bool_,
    pub nr_frozen_descendants: ffi::c_int,
    pub nr_frozen_tasks: ffi::c_int,
    pub freeze_seq: seqcount_spinlock_t,
    pub freeze_start_nsec: u64_,
    pub frozen_nsec: u64_,
}
#[repr(C)]
#[repr(align(64))]
pub struct cgroup {
    pub self_: cgroup_subsys_state,
    pub flags: ffi::c_ulong,
    pub level: ffi::c_int,
    pub max_depth: ffi::c_int,
    pub nr_descendants: ffi::c_int,
    pub nr_dying_descendants: ffi::c_int,
    pub max_descendants: ffi::c_int,
    pub nr_populated_csets: ffi::c_int,
    pub nr_populated_domain_children: ffi::c_int,
    pub nr_populated_threaded_children: ffi::c_int,
    pub nr_threaded_children: ffi::c_int,
    pub kill_seq: ffi::c_uint,
    pub kn: *mut kernfs_node,
    pub procs_file: cgroup_file,
    pub events_file: cgroup_file,
    pub psi_files: __IncompleteArrayField<cgroup_file>,
    pub subtree_control: u16_,
    pub subtree_ss_mask: u16_,
    pub old_subtree_control: u16_,
    pub old_subtree_ss_mask: u16_,
    pub subsys: [*mut cgroup_subsys_state; 14usize],
    pub nr_dying_subsys: [ffi::c_int; 14usize],
    pub root: *mut cgroup_root,
    pub cset_links: list_head,
    pub e_csets: [list_head; 14usize],
    pub dom_cgrp: *mut cgroup,
    pub old_dom_cgrp: *mut cgroup,
    pub rstat_base_cpu: *mut cgroup_rstat_base_cpu,
    pub __bindgen_padding_0: u64,
    pub _pad_: cacheline_padding,
    pub last_bstat: cgroup_base_stat,
    pub bstat: cgroup_base_stat,
    pub prev_cputime: prev_cputime,
    pub pidlists: list_head,
    pub pidlist_mutex: mutex,
    pub offline_waitq: wait_queue_head_t,
    pub release_agent_work: work_struct,
    pub psi: *mut psi_group,
    pub bpf: cgroup_bpf,
    pub freezer: cgroup_freezer_state,
    pub ancestors: __IncompleteArrayField<*mut cgroup>,
}
impl Default for cgroup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct cgroup_root {
    pub kf_root: *mut kernfs_root,
    pub subsys_mask: ffi::c_uint,
    pub hierarchy_id: ffi::c_int,
    pub root_list: list_head,
    pub rcu: callback_head,
    pub __bindgen_padding_0: [u64; 2usize],
    pub cgrp: cgroup,
    pub cgrp_ancestor_storage: *mut cgroup,
    pub nr_cgrps: atomic_t,
    pub flags: ffi::c_uint,
    pub release_agent_path: [ffi::c_char; 4096usize],
    pub name: [ffi::c_char; 64usize],
}
impl Default for cgroup_root {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cftype {
    pub name: [ffi::c_char; 64usize],
    pub private: ffi::c_ulong,
    pub max_write_len: usize,
    pub flags: ffi::c_uint,
    pub file_offset: ffi::c_uint,
    pub ss: *mut cgroup_subsys,
    pub node: list_head,
    pub kf_ops: *mut kernfs_ops,
    pub open: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file) -> ffi::c_int>,
    pub release: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file)>,
    pub read_u64: ::core::option::Option<
        unsafe extern "C" fn(css: *mut cgroup_subsys_state, cft: *mut cftype) -> u64_,
    >,
    pub read_s64: ::core::option::Option<
        unsafe extern "C" fn(css: *mut cgroup_subsys_state, cft: *mut cftype) -> s64,
    >,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, v: *mut ffi::c_void) -> ffi::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, ppos: *mut loff_t) -> *mut ffi::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            v: *mut ffi::c_void,
            ppos: *mut loff_t,
        ) -> *mut ffi::c_void,
    >,
    pub seq_stop:
        ::core::option::Option<unsafe extern "C" fn(sf: *mut seq_file, v: *mut ffi::c_void)>,
    pub write_u64: ::core::option::Option<
        unsafe extern "C" fn(
            css: *mut cgroup_subsys_state,
            cft: *mut cftype,
            val: u64_,
        ) -> ffi::c_int,
    >,
    pub write_s64: ::core::option::Option<
        unsafe extern "C" fn(
            css: *mut cgroup_subsys_state,
            cft: *mut cftype,
            val: s64,
        ) -> ffi::c_int,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut ffi::c_char,
            nbytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(of: *mut kernfs_open_file, pt: *mut poll_table_struct) -> __poll_t,
    >,
    pub lockdep_key: lock_class_key,
}
impl Default for cftype {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_subsys {
    pub css_alloc: ::core::option::Option<
        unsafe extern "C" fn(parent_css: *mut cgroup_subsys_state) -> *mut cgroup_subsys_state,
    >,
    pub css_online:
        ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state) -> ffi::c_int>,
    pub css_offline: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_released: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_free: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_reset: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_killed: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_rstat_flush: ::core::option::Option<
        unsafe extern "C" fn(css: *mut cgroup_subsys_state, cpu: ffi::c_int),
    >,
    pub css_extra_stat_show: ::core::option::Option<
        unsafe extern "C" fn(seq: *mut seq_file, css: *mut cgroup_subsys_state) -> ffi::c_int,
    >,
    pub css_local_stat_show: ::core::option::Option<
        unsafe extern "C" fn(seq: *mut seq_file, css: *mut cgroup_subsys_state) -> ffi::c_int,
    >,
    pub can_attach:
        ::core::option::Option<unsafe extern "C" fn(tset: *mut cgroup_taskset) -> ffi::c_int>,
    pub cancel_attach: ::core::option::Option<unsafe extern "C" fn(tset: *mut cgroup_taskset)>,
    pub attach: ::core::option::Option<unsafe extern "C" fn(tset: *mut cgroup_taskset)>,
    pub can_fork: ::core::option::Option<
        unsafe extern "C" fn(task: *mut task_struct, cset: *mut css_set) -> ffi::c_int,
    >,
    pub cancel_fork:
        ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct, cset: *mut css_set)>,
    pub fork: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
    pub exit: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
    pub release: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
    pub bind: ::core::option::Option<unsafe extern "C" fn(root_css: *mut cgroup_subsys_state)>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub id: ffi::c_int,
    pub name: *const ffi::c_char,
    pub legacy_name: *const ffi::c_char,
    pub root: *mut cgroup_root,
    pub css_idr: idr,
    pub cfts: list_head,
    pub dfl_cftypes: *mut cftype,
    pub legacy_cftypes: *mut cftype,
    pub depends_on: ffi::c_uint,
    pub rstat_ss_lock: spinlock_t,
    pub lhead: *mut llist_head,
}
impl Default for cgroup_subsys {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl cgroup_subsys {
    #[inline]
    pub fn early_init(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn early_init_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_early_init_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn implicit_on_dfl(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_implicit_on_dfl(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn implicit_on_dfl_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_implicit_on_dfl_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn threaded(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_threaded(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn threaded_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_threaded_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        early_init: bool_,
        implicit_on_dfl: bool_,
        threaded: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
            early_init as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let implicit_on_dfl: u8 = unsafe { ::core::mem::transmute(implicit_on_dfl) };
            implicit_on_dfl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let threaded: u8 = unsafe { ::core::mem::transmute(threaded) };
            threaded as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fprop_local_percpu {
    pub events: percpu_counter,
    pub period: ffi::c_uint,
    pub lock: raw_spinlock_t,
}
impl Default for fprop_local_percpu {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const wb_reason_WB_REASON_BACKGROUND: wb_reason = 0;
pub const wb_reason_WB_REASON_VMSCAN: wb_reason = 1;
pub const wb_reason_WB_REASON_SYNC: wb_reason = 2;
pub const wb_reason_WB_REASON_PERIODIC: wb_reason = 3;
pub const wb_reason_WB_REASON_LAPTOP_TIMER: wb_reason = 4;
pub const wb_reason_WB_REASON_FS_FREE_SPACE: wb_reason = 5;
pub const wb_reason_WB_REASON_FORKER_THREAD: wb_reason = 6;
pub const wb_reason_WB_REASON_FOREIGN_FLUSH: wb_reason = 7;
pub const wb_reason_WB_REASON_MAX: wb_reason = 8;
pub type wb_reason = ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bdi_writeback {
    pub bdi: *mut backing_dev_info,
    pub state: ffi::c_ulong,
    pub last_old_flush: ffi::c_ulong,
    pub b_dirty: list_head,
    pub b_io: list_head,
    pub b_more_io: list_head,
    pub b_dirty_time: list_head,
    pub list_lock: spinlock_t,
    pub writeback_inodes: atomic_t,
    pub stat: [percpu_counter; 4usize],
    pub bw_time_stamp: ffi::c_ulong,
    pub dirtied_stamp: ffi::c_ulong,
    pub written_stamp: ffi::c_ulong,
    pub write_bandwidth: ffi::c_ulong,
    pub avg_write_bandwidth: ffi::c_ulong,
    pub dirty_ratelimit: ffi::c_ulong,
    pub balanced_dirty_ratelimit: ffi::c_ulong,
    pub completions: fprop_local_percpu,
    pub dirty_exceeded: ffi::c_int,
    pub start_all_reason: wb_reason,
    pub work_lock: spinlock_t,
    pub work_list: list_head,
    pub dwork: delayed_work,
    pub bw_dwork: delayed_work,
    pub bdi_node: list_head,
}
impl Default for bdi_writeback {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct backing_dev_info {
    pub id: u64_,
    pub rb_node: rb_node,
    pub bdi_list: list_head,
    pub ra_pages: ffi::c_ulong,
    pub io_pages: ffi::c_ulong,
    pub refcnt: kref,
    pub capabilities: ffi::c_uint,
    pub min_ratio: ffi::c_uint,
    pub max_ratio: ffi::c_uint,
    pub max_prop_frac: ffi::c_uint,
    pub tot_write_bandwidth: atomic_long_t,
    pub last_bdp_sleep: ffi::c_ulong,
    pub wb: bdi_writeback,
    pub wb_list: list_head,
    pub wb_waitq: wait_queue_head_t,
    pub dev: *mut device,
    pub dev_name: [ffi::c_char; 64usize],
    pub owner: *mut device,
    pub laptop_mode_wb_timer: timer_list,
    pub debug_dir: *mut dentry,
}
impl Default for backing_dev_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_vec {
    pub bv_page: *mut page,
    pub bv_len: ffi::c_uint,
    pub bv_offset: ffi::c_uint,
}
impl Default for bio_vec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct block_device {
    pub bd_start_sect: sector_t,
    pub bd_nr_sectors: sector_t,
    pub bd_disk: *mut gendisk,
    pub bd_queue: *mut request_queue,
    pub bd_stats: *mut disk_stats,
    pub bd_stamp: ffi::c_ulong,
    pub __bd_flags: atomic_t,
    pub bd_dev: dev_t,
    pub bd_mapping: *mut address_space,
    pub bd_openers: atomic_t,
    pub bd_size_lock: spinlock_t,
    pub bd_claiming: *mut ffi::c_void,
    pub bd_holder: *mut ffi::c_void,
    pub bd_holder_ops: *mut blk_holder_ops,
    pub bd_holder_lock: mutex,
    pub bd_holders: ffi::c_int,
    pub bd_holder_dir: *mut kobject,
    pub bd_fsfreeze_count: atomic_t,
    pub bd_fsfreeze_mutex: mutex,
    pub bd_meta_info: *mut partition_meta_info,
    pub bd_writers: ffi::c_int,
    pub bd_security: *mut ffi::c_void,
    pub bd_device: device,
}
impl Default for block_device {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct folio_batch {
    pub nr: ffi::c_uchar,
    pub i: ffi::c_uchar,
    pub percpu_pvec_drained: bool_,
    pub folios: [*mut folio; 31usize],
}
impl Default for folio_batch {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn folio_batch_remove_exceptionals(fbatch: *mut folio_batch);
}
pub const writeback_sync_modes_WB_SYNC_NONE: writeback_sync_modes = 0;
pub const writeback_sync_modes_WB_SYNC_ALL: writeback_sync_modes = 1;
pub type writeback_sync_modes = ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct writeback_control {
    pub nr_to_write: ffi::c_long,
    pub pages_skipped: ffi::c_long,
    pub range_start: loff_t,
    pub range_end: loff_t,
    pub sync_mode: writeback_sync_modes,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub fbatch: folio_batch,
    pub index: ffi::c_ulong,
    pub saved_err: ffi::c_int,
}
impl Default for writeback_control {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl writeback_control {
    #[inline]
    pub fn for_kupdate(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_kupdate(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn for_kupdate_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_for_kupdate_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn for_background(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_background(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn for_background_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_for_background_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tagged_writepages(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tagged_writepages(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tagged_writepages_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tagged_writepages_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn range_cyclic(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_range_cyclic(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn range_cyclic_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_range_cyclic_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn for_sync(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_sync(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn for_sync_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_for_sync_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn unpinned_netfs_wb(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unpinned_netfs_wb(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn unpinned_netfs_wb_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_unpinned_netfs_wb_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn no_cgroup_owner(&self) -> ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_owner(&mut self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_cgroup_owner_raw(this: *const Self) -> ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_no_cgroup_owner_raw(this: *mut Self, val: ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        for_kupdate: ffi::c_uint,
        for_background: ffi::c_uint,
        tagged_writepages: ffi::c_uint,
        range_cyclic: ffi::c_uint,
        for_sync: ffi::c_uint,
        unpinned_netfs_wb: ffi::c_uint,
        no_cgroup_owner: ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let for_kupdate: u32 = unsafe { ::core::mem::transmute(for_kupdate) };
            for_kupdate as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let for_background: u32 = unsafe { ::core::mem::transmute(for_background) };
            for_background as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tagged_writepages: u32 = unsafe { ::core::mem::transmute(tagged_writepages) };
            tagged_writepages as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let range_cyclic: u32 = unsafe { ::core::mem::transmute(range_cyclic) };
            range_cyclic as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let for_sync: u32 = unsafe { ::core::mem::transmute(for_sync) };
            for_sync as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let unpinned_netfs_wb: u32 = unsafe { ::core::mem::transmute(unpinned_netfs_wb) };
            unpinned_netfs_wb as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let no_cgroup_owner: u32 = unsafe { ::core::mem::transmute(no_cgroup_owner) };
            no_cgroup_owner as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub fn folio_redirty_for_writepage(arg1: *mut writeback_control, arg2: *mut folio) -> bool_;
}
unsafe extern "C" {
    pub fn security_task_to_inode(p: *mut task_struct, inode: *mut inode);
}
pub const fs_context_purpose_FS_CONTEXT_FOR_MOUNT: fs_context_purpose = 0;
pub const fs_context_purpose_FS_CONTEXT_FOR_SUBMOUNT: fs_context_purpose = 1;
pub const fs_context_purpose_FS_CONTEXT_FOR_RECONFIGURE: fs_context_purpose = 2;
pub type fs_context_purpose = ffi::c_uint;
pub const fs_context_phase_FS_CONTEXT_CREATE_PARAMS: fs_context_phase = 0;
pub const fs_context_phase_FS_CONTEXT_CREATING: fs_context_phase = 1;
pub const fs_context_phase_FS_CONTEXT_AWAITING_MOUNT: fs_context_phase = 2;
pub const fs_context_phase_FS_CONTEXT_AWAITING_RECONF: fs_context_phase = 3;
pub const fs_context_phase_FS_CONTEXT_RECONF_PARAMS: fs_context_phase = 4;
pub const fs_context_phase_FS_CONTEXT_RECONFIGURING: fs_context_phase = 5;
pub const fs_context_phase_FS_CONTEXT_FAILED: fs_context_phase = 6;
pub type fs_context_phase = ffi::c_uint;
pub const fs_value_type_fs_value_is_undefined: fs_value_type = 0;
pub const fs_value_type_fs_value_is_flag: fs_value_type = 1;
pub const fs_value_type_fs_value_is_string: fs_value_type = 2;
pub const fs_value_type_fs_value_is_blob: fs_value_type = 3;
pub const fs_value_type_fs_value_is_filename: fs_value_type = 4;
pub const fs_value_type_fs_value_is_file: fs_value_type = 5;
pub type fs_value_type = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_parameter {
    pub key: *const ffi::c_char,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_anon_1: fs_parameter__bindgen_ty_1,
    pub size: usize,
    pub dirfd: ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fs_parameter__bindgen_ty_1 {
    pub string: *mut ffi::c_char,
    pub blob: *mut ffi::c_void,
    pub name: *mut filename,
    pub file: *mut file,
}
impl Default for fs_parameter__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for fs_parameter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl fs_parameter {
    #[inline]
    pub fn type_(&self) -> fs_value_type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: fs_value_type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn type__raw(this: *const Self) -> fs_value_type {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_type_raw(this: *mut Self, val: fs_value_type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(type_: fs_value_type) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct p_log {
    pub prefix: *const ffi::c_char,
    pub log: *mut fc_log,
}
impl Default for p_log {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_context {
    pub ops: *const fs_context_operations,
    pub uapi_mutex: mutex,
    pub fs_type: *mut file_system_type,
    pub fs_private: *mut ffi::c_void,
    pub sget_key: *mut ffi::c_void,
    pub root: *mut dentry,
    pub user_ns: *mut user_namespace,
    pub net_ns: *mut net,
    pub cred: *const cred,
    pub log: p_log,
    pub source: *const ffi::c_char,
    pub security: *mut ffi::c_void,
    pub s_fs_info: *mut ffi::c_void,
    pub sb_flags: ffi::c_uint,
    pub sb_flags_mask: ffi::c_uint,
    pub s_iflags: ffi::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl Default for fs_context {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl fs_context {
    #[inline]
    pub fn purpose(&self) -> fs_context_purpose {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_purpose(&mut self, val: fs_context_purpose) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn purpose_raw(this: *const Self) -> fs_context_purpose {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_purpose_raw(this: *mut Self, val: fs_context_purpose) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn phase(&self) -> fs_context_phase {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_phase(&mut self, val: fs_context_phase) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn phase_raw(this: *const Self) -> fs_context_phase {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_phase_raw(this: *mut Self, val: fs_context_phase) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn need_free(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_need_free(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn need_free_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_need_free_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn global(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_global(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn global_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_global_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn oldapi(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_oldapi(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn oldapi_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_oldapi_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn exclusive(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_exclusive(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn exclusive_raw(this: *const Self) -> bool_ {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_exclusive_raw(this: *mut Self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        purpose: fs_context_purpose,
        phase: fs_context_phase,
        need_free: bool_,
        global: bool_,
        oldapi: bool_,
        exclusive: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let purpose: u32 = unsafe { ::core::mem::transmute(purpose) };
            purpose as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let phase: u32 = unsafe { ::core::mem::transmute(phase) };
            phase as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let need_free: u8 = unsafe { ::core::mem::transmute(need_free) };
            need_free as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let global: u8 = unsafe { ::core::mem::transmute(global) };
            global as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let oldapi: u8 = unsafe { ::core::mem::transmute(oldapi) };
            oldapi as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let exclusive: u8 = unsafe { ::core::mem::transmute(exclusive) };
            exclusive as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fs_context_operations {
    pub free: ::core::option::Option<unsafe extern "C" fn(fc: *mut fs_context)>,
    pub dup: ::core::option::Option<
        unsafe extern "C" fn(fc: *mut fs_context, src_fc: *mut fs_context) -> ffi::c_int,
    >,
    pub parse_param: ::core::option::Option<
        unsafe extern "C" fn(fc: *mut fs_context, param: *mut fs_parameter) -> ffi::c_int,
    >,
    pub parse_monolithic: ::core::option::Option<
        unsafe extern "C" fn(fc: *mut fs_context, data: *mut ffi::c_void) -> ffi::c_int,
    >,
    pub get_tree: ::core::option::Option<unsafe extern "C" fn(fc: *mut fs_context) -> ffi::c_int>,
    pub reconfigure:
        ::core::option::Option<unsafe extern "C" fn(fc: *mut fs_context) -> ffi::c_int>,
}
unsafe extern "C" {
    pub fn fs_context_for_mount(
        fs_type: *mut file_system_type,
        sb_flags: ffi::c_uint,
    ) -> *mut fs_context;
}
unsafe extern "C" {
    pub fn fs_context_for_reconfigure(
        dentry: *mut dentry,
        sb_flags: ffi::c_uint,
        sb_flags_mask: ffi::c_uint,
    ) -> *mut fs_context;
}
unsafe extern "C" {
    pub fn fs_context_for_submount(
        fs_type: *mut file_system_type,
        reference: *mut dentry,
    ) -> *mut fs_context;
}
unsafe extern "C" {
    pub fn generic_parse_monolithic(fc: *mut fs_context, data: *mut ffi::c_void) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn get_tree_nodev(
        fc: *mut fs_context,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, fc: *mut fs_context) -> ffi::c_int,
        >,
    ) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn get_tree_single(
        fc: *mut fs_context,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, fc: *mut fs_context) -> ffi::c_int,
        >,
    ) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn get_tree_keyed(
        fc: *mut fs_context,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, fc: *mut fs_context) -> ffi::c_int,
        >,
        key: *mut ffi::c_void,
    ) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn get_tree_bdev_flags(
        fc: *mut fs_context,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, fc: *mut fs_context) -> ffi::c_int,
        >,
        flags: ffi::c_uint,
    ) -> ffi::c_int;
}
unsafe extern "C" {
    pub fn get_tree_bdev(
        fc: *mut fs_context,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, fc: *mut fs_context) -> ffi::c_int,
        >,
    ) -> ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fc_log {
    pub usage: refcount_t,
    pub head: u8_,
    pub tail: u8_,
    pub need_free: u8_,
    pub owner: *mut module,
    pub buffer: [*mut ffi::c_char; 8usize],
}
impl Default for fc_log {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BINDINGS_SLAB_RECLAIM_ACCOUNT: slab_flags_t = 16384;
pub const BINDINGS_SLAB_ACCOUNT: slab_flags_t = 0;
pub const BINDINGS_MAX_LFS_FILESIZE: loff_t = 9223372036854775807;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernel_symbol {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct module_sect_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct module_notes_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct trace_event_call {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct trace_eval_map {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct files_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rt_mutex_waiter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gendisk {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldt_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct page_pool {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linux_binfmt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct assoc_array_ptr {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct key_user {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tty_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tty_audit_buf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct request_queue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct wait_page_queue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct file_lock_context {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cdev {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xattr_handler {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mtd_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kernfs_root {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct module_param_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dev_pm_qos {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct of_device_id {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct acpi_device_id {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bus_dma_region {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_tlb_mem {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct disk_stats {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct blk_holder_ops {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct partition_meta_info {
    pub _address: u8,
}
